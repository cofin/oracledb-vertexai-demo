#!/usr/bin/env python3
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "httpx>=0.28.1",
#     "rich-click>=1.8.0",
#     "oracledb>=2.0.0",
#     "python-dotenv>=1.0.0",
# ]
# ///
"""Unified project management CLI for Oracle + Vertex AI demo.

This tool provides a single interface for:
- Project initialization and environment setup
- Prerequisite installation (UV, SQLcl, etc.)
- Oracle database deployment (managed container or external connection)
- Wallet configuration and validation (auto-detected)
- Connection testing and health checks

IMPORTANT: This is a development tool and should not be shipped with production code.

Usage:
    python manage.py init                  # Initialize project
    python manage.py install all          # Install all prerequisites
    python manage.py doctor               # Verify setup
    python manage.py database start       # Start Oracle container
    python manage.py --help               # Show all commands
"""

from __future__ import annotations

import contextlib
import os
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Any

import rich_click as click
from rich.console import Console
from rich.prompt import Confirm, Prompt
from rich.table import Table

# Ensure tools package is importable
sys.path.insert(0, str(Path(__file__).parent))

console = Console()

# Configure rich-click
click.rich_click.USE_RICH_MARKUP = True
click.rich_click.SHOW_ARGUMENTS = True
click.rich_click.GROUP_ARGUMENTS_OPTIONS = True
click.rich_click.STYLE_ERRORS_SUGGESTION = "yellow italic"
click.rich_click.ERRORS_SUGGESTION = "Try running the '--help' flag for more information."


# ============================================================================
# Utility Functions
# ============================================================================


def detect_deployment_mode() -> str:
    """Detect deployment mode from environment.

    Returns:
        str: "managed" or "external"

    Detection logic:
        - If DATABASE_HOST or DATABASE_URL is set -> external
        - Otherwise -> managed (Docker container we control)

    Wallet detection is automatic - if TNS_ADMIN/WALLET_LOCATION is set,
    wallet-based connection will be used regardless of mode.
    """
    if os.getenv("DATABASE_HOST") or os.getenv("DATABASE_URL"):
        return "external"
    return "managed"


def check_env_file() -> bool:
    """Check if .env file exists."""
    return Path(".env").exists()


def generate_secret_key() -> str:
    """Generate a secure random secret key."""
    import secrets

    return secrets.token_hex(32)


def create_env_interactive(mode: str, non_interactive: bool = False) -> bool:  # noqa: C901, PLR0915
    """Create .env file interactively based on deployment mode.

    Args:
        mode: Deployment mode ("managed" or "external")
        non_interactive: If True, use defaults without prompting

    Returns:
        bool: True if successful, False otherwise
    """
    env_path = Path(".env")

    if env_path.exists():
        console.print("[yellow]⚠ .env already exists[/yellow]")
        if not non_interactive:
            overwrite = Confirm.ask("Overwrite existing .env?", default=False)
            if not overwrite:
                console.print("[cyan]Keeping existing .env[/cyan]")
                return True

    console.print(f"[bold]Creating .env for [cyan]{mode}[/cyan] mode...[/bold]")
    console.print()

    # Core application settings (always required)
    default_secret = generate_secret_key()
    if non_interactive:
        secret_key = default_secret
        google_project = "demo-project"
        google_api_key = ""
    else:
        console.print("[bold]Core Application Settings:[/bold]")
        secret_key = Prompt.ask("SECRET_KEY (press Enter to auto-generate)", default=default_secret, show_default=False)
        console.print()

        console.print("[bold]Google Cloud / Vertex AI Settings:[/bold]")
        google_project = Prompt.ask("GOOGLE_CLOUD_PROJECT", default="demo-project")
        google_api_key = Prompt.ask("GOOGLE_API_KEY (optional)", default="")

    env_content = "# Application Configuration\n"
    env_content += "# Generated by: python manage.py init\n\n"

    # Database configuration based on mode
    if mode == "managed":
        # Managed mode: container with known defaults
        if non_interactive:
            db_user = "app"
            db_password = "super-secret"  # noqa: S105
            db_host = "localhost"
            db_port = "1521"
            db_service = "freepdb1"
        else:
            console.print("[bold]Database Settings (Managed Container):[/bold]")
            db_user = Prompt.ask("DATABASE_USER", default="app")
            db_password = Prompt.ask("DATABASE_PASSWORD", default="super-secret")
            db_host = Prompt.ask("DATABASE_HOST", default="localhost")
            db_port = Prompt.ask("DATABASE_PORT", default="1521")
            db_service = Prompt.ask("DATABASE_SERVICE_NAME", default="freepdb1")

        env_content += "# Database (Managed Container)\n"
        env_content += f"DATABASE_USER={db_user}\n"
        env_content += f"DATABASE_PASSWORD={db_password}\n"
        env_content += f"DATABASE_HOST={db_host}\n"
        env_content += f"DATABASE_PORT={db_port}\n"
        env_content += f"DATABASE_SERVICE_NAME={db_service}\n\n"

    elif non_interactive:
        use_wallet = False
        db_user = "app"
        db_password = "your-password"  # noqa: S105
        db_host = "your-oracle-host"
        db_port = "1521"
        db_service = "your-service-name"
    else:
        console.print("[bold]External Database Connection:[/bold]")
        use_wallet = Confirm.ask("Use wallet-based connection (Autonomous DB, mTLS)?", default=False)

        if use_wallet:
            console.print("[dim]Using DATABASE_URL format for wallet connections[/dim]")
            db_url = Prompt.ask("DATABASE_URL", default="oracle+oracledb://ADMIN:password@service_high")
            wallet_password = Prompt.ask("WALLET_PASSWORD", default="")
            wallet_location = Prompt.ask("WALLET_LOCATION/TNS_ADMIN", default="./.envs/tns")

            env_content += "# Database (External - Wallet/Autonomous)\n"
            env_content += f"DATABASE_URL={db_url}\n"
            if wallet_password:
                env_content += f"WALLET_PASSWORD={wallet_password}\n"
            env_content += f"TNS_ADMIN={wallet_location}\n\n"
        else:
            console.print("[dim]Using standard connection parameters[/dim]")
            db_user = Prompt.ask("DATABASE_USER", default="app")
            db_password = Prompt.ask("DATABASE_PASSWORD", default="your-password")
            db_host = Prompt.ask("DATABASE_HOST", default="your-oracle-host")
            db_port = Prompt.ask("DATABASE_PORT", default="1521")
            db_service = Prompt.ask("DATABASE_SERVICE_NAME", default="your-service-name")

            env_content += "# Database (External - Standard)\n"
            env_content += f"DATABASE_USER={db_user}\n"
            env_content += f"DATABASE_PASSWORD={db_password}\n"
            env_content += f"DATABASE_HOST={db_host}\n"
            env_content += f"DATABASE_PORT={db_port}\n"
            env_content += f"DATABASE_SERVICE_NAME={db_service}\n\n"

    # Google Cloud settings
    env_content += "# Google Cloud / Vertex AI\n"
    env_content += f"GOOGLE_CLOUD_PROJECT={google_project}\n"
    if google_api_key:
        env_content += f"GOOGLE_API_KEY={google_api_key}\n"
    env_content += "\n"

    # Server settings
    env_content += "# Server Configuration\n"
    env_content += "LITESTAR_DEBUG=true\n"
    env_content += "LITESTAR_HOST=0.0.0.0\n"
    env_content += "LITESTAR_PORT=5006\n"
    env_content += "LITESTAR_GRANIAN_IN_SUBPROCESS=false\n"
    env_content += "LITESTAR_GRANIAN_USE_LITESTAR_LOGGER=true\n"
    env_content += f"SECRET_KEY={secret_key}\n\n"

    # Development settings
    env_content += "# Development (optional)\n"
    env_content += "# VITE_HOST=localhost\n"
    env_content += "# VITE_PORT=51745\n"
    env_content += "# VITE_HOT_RELOAD=False\n"
    env_content += "# VITE_DEV_MODE=False\n"

    try:
        env_path.write_text(env_content)
        console.print("[green]✓ Created .env file[/green]")
    except Exception as e:  # noqa: BLE001
        console.print(f"[red]✗ Failed to create .env: {e}[/red]")
        return False
    else:
        return True


def run_command(cmd: list[str], check: bool = True) -> tuple[int, str, str]:
    """Run shell command and return exit code, stdout, stderr."""
    try:
        result = subprocess.run(  # noqa: S603
            cmd,
            capture_output=True,
            text=True,
            check=check,
        )
    except subprocess.CalledProcessError as e:
        return e.returncode, e.stdout, e.stderr
    except Exception as e:  # noqa: BLE001
        return 1, "", str(e)
    else:
        return result.returncode, result.stdout, result.stderr


def is_tool_installed(tool_name: str, version_flag: str = "--version") -> tuple[bool, str]:
    """Check if a tool is installed and available in PATH.

    Args:
        tool_name: Name of the executable to check (e.g., 'uv', 'sql', 'gemini')
        version_flag: Flag to get version (default: '--version')

    Returns:
        tuple[bool, str]: (is_installed, version_string)
    """
    if not shutil.which(tool_name):
        return False, ""

    try:
        returncode, stdout, _ = run_command([tool_name, version_flag], check=False)
        if returncode == 0:
            return True, stdout.strip()
    except Exception:  # noqa: BLE001, S110
        pass

    return False, ""


def is_mcp_server_configured(server_name: str) -> bool:
    """Check if an MCP server is already configured in Gemini settings.

    Args:
        server_name: Name of the MCP server (e.g., 'sqlcl', 'sequential-thinking')

    Returns:
        bool: True if server is already configured
    """
    import json

    gemini_settings_path = Path.home() / ".gemini" / "settings.json"
    if not gemini_settings_path.exists():
        return False

    try:
        with gemini_settings_path.open() as f:
            settings = json.load(f)
        mcp_servers = settings.get("mcpServers", {})
        # Check if server exists and is not None/null
        return server_name in mcp_servers and mcp_servers[server_name] is not None
    except Exception:  # noqa: BLE001
        return False


def is_sqlcl_connection_saved(connection_name: str = "cymbal_coffee") -> bool:
    """Check if a SQLcl saved connection exists.

    Args:
        connection_name: Name of the saved connection

    Returns:
        bool: True if connection is saved
    """
    if not shutil.which("sql"):
        return False

    try:
        # Use sql -L to list saved connections
        result = subprocess.run(
            ["sql", "-L"],  # noqa: S607
            capture_output=True,
            text=True,
            timeout=5,
            check=False,
        )
    except Exception:  # noqa: BLE001
        return False
    else:
        # Check if connection_name appears in the output
        return connection_name in result.stdout


def migrate_sqlcl_connection(old_name: str = "mcp_demo", new_name: str = "cymbal_coffee") -> tuple[bool, str]:  # noqa: PLR0911
    """Migrate old SQLcl connection name to new name.

    Args:
        old_name: Old connection name to rename
        new_name: New connection name

    Returns:
        tuple[bool, str]: (success, message)
    """
    from dotenv import dotenv_values

    # Check if old connection exists
    if not is_sqlcl_connection_saved(old_name):
        return True, f"No '{old_name}' connection to migrate"

    # Check if new connection already exists
    if is_sqlcl_connection_saved(new_name):
        return True, f"Connection '{new_name}' already exists"

    # Load credentials from .env
    env_path = Path(".env")
    if not env_path.exists():
        return False, ".env file not found"

    env_vars = dotenv_values(env_path)
    user = env_vars.get("DATABASE_USER")
    password = env_vars.get("DATABASE_PASSWORD")
    host = env_vars.get("DATABASE_HOST")
    port = env_vars.get("DATABASE_PORT", "1521")
    service_name = env_vars.get("DATABASE_SERVICE_NAME")

    if not all([user, password, host, service_name]):
        return False, "Missing database credentials in .env"

    # Create new connection with new name
    conn_string = f"{user}/{password}@//{host}:{port}/{service_name}"
    conn_cmd = f"conn -save {new_name} -savepwd {conn_string}\nexit"

    try:
        result = subprocess.run(
            ["sql", "/nolog"],  # noqa: S607
            check=False,
            input=conn_cmd,
            capture_output=True,
            text=True,
            timeout=10,
        )

        if result.returncode == 0:
            # NOTE: SQLcl doesn't have a delete command for saved connections
            # The old connection will still exist but won't be used
            return True, f"Created connection '{new_name}' (old '{old_name}' still exists)"

    except subprocess.TimeoutExpired:
        return False, "SQLcl command timed out"
    except Exception as e:  # noqa: BLE001
        return False, f"Error migrating connection: {e}"
    else:
        return False, "Failed to create new connection"


def configure_sqlcl_connection_with_password(connection_name: str = "cymbal_coffee") -> tuple[bool, str]:  # noqa: C901, PLR0911
    """Configure SQLcl saved connection with password from .env.

    Args:
        connection_name: Name for the saved connection (default: cymbal_coffee)

    Returns:
        tuple[bool, str]: Success status and message

    SQLcl MCP requires a saved connection with password using the -savepwd flag.
    This function creates a saved connection using credentials from .env.

    Command format:
        conn -save <name> -savepwd username/password@//host:port/service
    """
    from dotenv import dotenv_values

    # Check if connection already exists
    if is_sqlcl_connection_saved(connection_name):
        return True, f"Connection '{connection_name}' already configured"

    # Check for old connection name and migrate
    if connection_name == "cymbal_coffee" and is_sqlcl_connection_saved("mcp_demo"):
        console.print("[yellow]🔄 Migrating old connection 'mcp_demo' to 'cymbal_coffee'...[/yellow]")
        success, message = migrate_sqlcl_connection("mcp_demo", "cymbal_coffee")
        if success:
            return True, message
        console.print(f"[yellow]⚠ Migration warning: {message}[/yellow]")
        # Continue to create new connection even if migration failed

    # Load .env values
    env_path = Path(".env")
    if not env_path.exists():
        return False, ".env file not found - run 'python manage.py init' first"

    env_vars = dotenv_values(env_path)

    # Get connection parameters
    user = env_vars.get("DATABASE_USER")
    password = env_vars.get("DATABASE_PASSWORD")
    host = env_vars.get("DATABASE_HOST")
    port = env_vars.get("DATABASE_PORT", "1521")
    service_name = env_vars.get("DATABASE_SERVICE_NAME")

    # Validate required parameters
    if not user:
        return False, "DATABASE_USER not configured in .env"
    if not password:
        return False, "DATABASE_PASSWORD not configured in .env"
    if not host:
        return False, "DATABASE_HOST not configured in .env"
    if not service_name:
        return False, "DATABASE_SERVICE_NAME not configured in .env"

    # Check if SQLcl is installed
    if not shutil.which("sql"):
        return False, "SQLcl not found in PATH - run 'python manage.py install sqlcl' first"

    # Build connection string (Oracle format with //)
    conn_string = f"{user}/{password}@//{host}:{port}/{service_name}"

    # Use echo to pipe the connection command
    conn_cmd = f"conn -save {connection_name} -savepwd {conn_string}\nexit"

    try:
        result = subprocess.run(
            ["sql", "/nolog"],  # noqa: S607
            check=False,
            input=conn_cmd,
            capture_output=True,
            text=True,
            timeout=10,
        )

        # Check if successful
        if result.returncode == 0:
            return True, f"Saved connection '{connection_name}' configured for {user}@//{host}:{port}/{service_name}"
        error_msg = result.stderr or result.stdout

    except subprocess.TimeoutExpired:
        return False, "SQLcl command timed out"
    except Exception as e:  # noqa: BLE001
        return False, f"Error running SQLcl: {e}"
    else:
        return False, f"Failed to save connection: {error_msg}"


def configure_gemini_mcp_sqlcl() -> bool:
    """Configure SQLcl as a Gemini MCP server.

    Returns:
        bool: True if configuration was successful or already exists, False otherwise

    Adds or updates SQLcl MCP server configuration in ~/.gemini/settings.json.
    Configuration format:
    {
        "mcpServers": {
            "sqlcl": {
                "command": "sql",
                "args": ["-mcp"]
            }
        }
    }
    """
    import json

    # Check if already configured
    if is_mcp_server_configured("sqlcl"):
        return True  # Already configured, no need to modify

    gemini_settings_path = Path.home() / ".gemini" / "settings.json"

    # Check if Gemini settings directory exists
    if not gemini_settings_path.parent.exists():
        try:
            gemini_settings_path.parent.mkdir(parents=True, exist_ok=True)
        except Exception:  # noqa: BLE001
            return False

    # Read existing settings or create new
    settings: dict[str, Any] = {}
    if gemini_settings_path.exists():
        try:
            with gemini_settings_path.open() as f:
                settings = json.load(f)
        except Exception:  # noqa: BLE001
            return False

    # Ensure mcpServers key exists
    if "mcpServers" not in settings:
        settings["mcpServers"] = {}

    # Add or update SQLcl configuration
    settings["mcpServers"]["sqlcl"] = {"command": "sql", "args": ["-mcp"]}

    # Write back to file
    try:
        with gemini_settings_path.open("w") as f:
            json.dump(settings, f, indent=2)
    except Exception:  # noqa: BLE001
        return False
    else:
        return True


def _configure_missing_mcp_extensions() -> None:
    """Configure MCP extensions that are not already configured.

    Checks for:
    - SQLcl (if installed and not configured)
    - Sequential Thinking (if not configured)
    - Context7 (if not configured)

    Only prompts for missing extensions.
    """
    # Check SQLcl
    sqlcl_path = shutil.which("sql")
    if sqlcl_path and not is_mcp_server_configured("sqlcl"):
        console.print()
        console.print("[bold cyan]SQLcl (Oracle Database)[/bold cyan]")
        console.print("[dim]Oracle database operations and SQL execution[/dim]")
        if Confirm.ask("Configure SQLcl MCP server?", default=True):
            # Step 1: Configure saved connection with password
            success, message = configure_sqlcl_connection_with_password()
            if success:
                console.print(f"[green]✓[/green] {message}")
            else:
                console.print(f"[yellow]⚠[/yellow] Password config: {message}")

            # Step 2: Configure Gemini MCP server
            if configure_gemini_mcp_sqlcl():
                console.print("[green]✓[/green] SQLcl MCP server configured")
    elif sqlcl_path:
        console.print("[dim]i SQLcl MCP server already configured[/dim]")

    # Configure other MCP extensions (only missing ones)
    results = configure_gemini_mcp_extensions(interactive=True)

    # Show summary
    console.print()
    console.print("[bold]MCP Configuration Summary:[/bold]")
    if sqlcl_path and is_mcp_server_configured("sqlcl"):
        console.print("  [green]✓[/green] sqlcl (Oracle Database)")
    for key, success in results.items():
        if success:
            console.print(f"  [green]✓[/green] {key}")
        else:
            console.print(f"  [dim]⊘ {key} (skipped)[/dim]")


def configure_gemini_mcp_extensions(interactive: bool = True) -> dict[str, bool]:  # noqa: C901
    """Configure popular Gemini MCP extensions.

    Args:
        interactive: If True, prompt user for each extension

    Returns:
        dict: Status of each extension configuration {extension_name: success}

    Configures:
    - sequential-thinking: Advanced reasoning capabilities
    - context7: Documentation and code context from popular libraries
    """
    import json

    gemini_settings_path = Path.home() / ".gemini" / "settings.json"
    results = {}

    # Check if Gemini settings directory exists
    if not gemini_settings_path.parent.exists():
        try:
            gemini_settings_path.parent.mkdir(parents=True, exist_ok=True)
        except Exception:  # noqa: BLE001
            return {"error": False}

    # Read existing settings or create new
    settings: dict[str, Any] = {}
    if gemini_settings_path.exists():
        try:
            with gemini_settings_path.open() as f:
                settings = json.load(f)
        except Exception:  # noqa: BLE001
            return {"error": False}

    # Ensure mcpServers key exists
    if "mcpServers" not in settings:
        settings["mcpServers"] = {}

    # Define extensions
    extensions = {
        "sequential-thinking": {
            "name": "Sequential Thinking",
            "description": "Advanced reasoning with step-by-step problem solving",
            "config": {
                "type": "stdio",
                "command": "npx",
                "args": ["-y", "@modelcontextprotocol/server-sequential-thinking"],
            },
        },
        "context7": {
            "name": "Context7",
            "description": "Documentation lookup for popular libraries and frameworks",
            "config": {"command": "npx", "args": ["-y", "@upstash/context7-mcp"]},
        },
    }

    # Configure each extension
    for key, ext in extensions.items():
        # Check if already configured (SKIP if exists)
        if is_mcp_server_configured(key):
            if interactive:
                console.print(f"[dim]i {ext['name']} already configured (skipping)[/dim]")
            results[key] = True  # Already configured = success
            continue

        # Interactive prompt for NEW extensions only
        should_install = True
        if interactive:
            console.print()
            console.print(f"[bold cyan]{ext['name']}[/bold cyan]")
            console.print(f"[dim]{ext['description']}[/dim]")
            should_install = Confirm.ask(f"Configure {ext['name']}?", default=True)

        if should_install:
            settings["mcpServers"][key] = ext["config"]
            results[key] = True
        else:
            results[key] = False

    # Write back to file
    try:
        with gemini_settings_path.open("w") as f:
            json.dump(settings, f, indent=2)
    except Exception:  # noqa: BLE001
        return dict.fromkeys(extensions.keys(), False)
    else:
        return results


# ============================================================================
# Main CLI Group
# ============================================================================


@click.group()
@click.version_option(version="0.1.0", prog_name="manage")
def cli() -> None:
    """Unified DevOps CLI for Oracle + Vertex AI Demo.

    This tool manages project initialization, prerequisites, database deployment,
    and configuration across two deployment modes:

    - managed: Oracle 23ai Free container via Docker/Podman (we control it)
    - external: Connect to existing database (auto-detects wallet for mTLS)
    """


# ============================================================================
# INIT COMMAND - Project Initialization
# ============================================================================


@cli.command()
@click.option(
    "--mode",
    type=click.Choice(["managed", "external"], case_sensitive=False),
    help="Deployment mode (auto-detect if not specified)",
)
@click.option(
    "--run-install",
    is_flag=True,
    help="Automatically run 'install all' after initialization",
)
@click.option(
    "--run-doctor",
    is_flag=True,
    help="Automatically run 'doctor' after initialization",
)
@click.option(
    "--non-interactive",
    is_flag=True,
    help="Skip interactive prompts (use defaults/env vars)",
)
def init(mode: str | None, run_install: bool, run_doctor: bool, non_interactive: bool) -> None:  # noqa: PLR0915, C901
    """Initialize project environment from scratch.

    This command:
    1. Detects or prompts for deployment mode (managed or external)
    2. Creates .env file with interactive prompts for all settings
    3. Configures database connection based on mode
    4. Optionally installs prerequisites
    5. Optionally verifies setup

    Modes:
    - managed: Deploy and manage an Oracle container (Docker/Podman)
    - external: Connect to existing database (standard or wallet-based)
    """
    console.rule("[bold blue]Project Initialization", style="blue", align="left")
    console.print()

    # Step 1: Determine deployment mode
    if mode is None:
        if check_env_file():
            # .env exists, detect mode from it
            mode = detect_deployment_mode()
            console.print(f"[cyan]🔍 Auto-detected mode from .env: [bold]{mode}[/bold][/cyan]")
        else:
            # No .env, ask user for mode
            console.print("[yellow]📄 No .env file found[/yellow]")
            if non_interactive:
                mode = "managed"
                console.print(f"[cyan]Using default mode: [bold]{mode}[/bold][/cyan]")
            else:
                mode = Prompt.ask(
                    "Select deployment mode",
                    choices=["managed", "external"],
                    default="managed",
                )

        if not non_interactive and check_env_file():
            change = Confirm.ask("Change deployment mode?", default=False)
            if change:
                mode = Prompt.ask(
                    "Select mode",
                    choices=["managed", "external"],
                    default=mode,
                )
    else:
        console.print(f"[cyan]📌 Using specified mode: [bold]{mode}[/bold][/cyan]")

    console.print()

    # Step 2: Create or update .env
    console.print("[yellow]📄 Configuring environment...[/yellow]")
    if not create_env_interactive(mode, non_interactive):
        console.print("[red]✗ Failed to configure .env file[/red]")
        raise click.Abort
    console.print()

    # Step 3: Show next steps based on mode
    console.print(f"[bold]Next steps for [cyan]{mode}[/cyan] mode:[/bold]")
    console.print()

    if mode == "managed":
        console.print("  1. Run: [cyan]python manage.py install all[/cyan]")
        console.print("  2. Run: [cyan]python manage.py database oracle start[/cyan]")
        console.print("  3. Run: [cyan]uv run app load-fixtures[/cyan]")
    else:  # external
        console.print(
            "  1. (If using wallet) Run: [cyan]python manage.py database oracle wallet extract Wallet_*.zip[/cyan]"
        )
        console.print("  2. Run: [cyan]python manage.py database oracle connect test[/cyan]")
        console.print("  3. Run: [cyan]uv run app load-fixtures[/cyan]")

    console.print()

    # Step 4: Optional auto-install
    if run_install:
        console.rule("[bold yellow]Running Installation", style="yellow")
        console.print()
        ctx = click.get_current_context()
        if ctx:
            ctx.invoke(install_all, mode=mode)

    # Step 5: Optional auto-doctor
    if run_doctor:
        console.rule("[bold yellow]Running Health Check", style="yellow")
        console.print()
        ctx = click.get_current_context()
        if ctx:
            ctx.invoke(doctor, mode=mode, json_output=False, verbose=False)

    # Final message
    console.print()
    console.rule("[bold green]Initialization Complete!", style="green")
    console.print()
    console.print("[bold green]✓ Project initialized successfully![/bold green]")
    console.print()
    console.print("[bold]Next:[/bold]")
    if not run_install:
        console.print("  • Run [cyan]python manage.py install all[/cyan] to install prerequisites")
    if not run_doctor:
        console.print("  • Run [cyan]python manage.py doctor[/cyan] to verify setup")
    console.print("  • Review and update [cyan].env[/cyan] if needed")
    console.print("  • See [cyan]README.md[/cyan] for detailed setup instructions")
    console.print()


# ============================================================================
# INSTALL COMMAND GROUP - Prerequisites Installation
# ============================================================================


@cli.group()
def install() -> None:
    """Install external tool prerequisites.

    Manages installation of:
    - UV: Astral's fast Python package manager
    - SQLcl: Oracle's SQL command-line tool
    - (Future: Docker, Podman, etc.)
    """


@install.command(name="all")
@click.option(
    "--mode",
    type=click.Choice(["managed", "external"], case_sensitive=False),
    help="Install prerequisites for specific mode (auto-detect if not specified)",
)
@click.option(
    "--force",
    is_flag=True,
    help="Force reinstall even if already installed",
)
@click.option(
    "--yes",
    "-y",
    is_flag=True,
    help="Skip confirmation prompts",
)
def install_all(mode: str | None, force: bool, yes: bool) -> None:
    """Install all prerequisites for deployment mode.

    Idempotent: Safe to run multiple times. Skips if already installed unless --force is used.

    Mode-specific installations:
    - managed: UV, Docker check
    - external: UV
    """
    if mode is None:
        mode = detect_deployment_mode()

    console.rule(f"[bold blue]Installing Prerequisites for '{mode}' Mode", style="blue")
    console.print()

    # UV is required for all modes
    console.print("[bold]Required for all modes:[/bold]")
    console.print("  • UV package manager")
    console.print()

    if mode == "managed":
        console.print("[bold]Additional for managed mode:[/bold]")
        console.print("  • Docker or Podman (checked, not auto-installed)")
        console.print()

    if not yes and not Confirm.ask("Proceed with installation?", default=True):
        console.print("[yellow]Installation cancelled[/yellow]")
        return

    # Install UV
    ctx = click.get_current_context()
    if ctx:
        ctx.invoke(install_uv, force=force)

    # For managed mode, check Docker/Podman
    if mode == "managed":
        console.print()
        console.print("[yellow]🐋 Checking for Docker/Podman...[/yellow]")

        has_docker = shutil.which("docker") is not None
        has_podman = shutil.which("podman") is not None

        if has_docker:
            console.print("[green]✓ Docker found[/green]")
        elif has_podman:
            console.print("[green]✓ Podman found[/green]")
        else:
            console.print("[red]✗ Neither Docker nor Podman found[/red]")
            console.print()
            console.print("[yellow]⚠ Managed mode requires Docker or Podman[/yellow]")
            console.print("[dim]Install from: https://www.docker.com/get-started[/dim]")

    console.print()
    console.print("[green]✓ Installation complete![/green]")


@install.command(name="list")
def install_list() -> None:
    """List available installation components."""
    console.rule("[bold blue]Available Installation Components", style="blue")
    console.print()

    table = Table(show_header=True, header_style="bold cyan")
    table.add_column("Component", style="cyan", width=15)
    table.add_column("Required", width=10)
    table.add_column("Modes", width=30)
    table.add_column("Description")

    table.add_row(
        "uv",
        "[green]Yes[/green]",
        "managed, external",
        "Fast Python package manager",
    )
    table.add_row(
        "java",
        "[yellow]Optional[/yellow]",
        "managed, external",
        "Java 11+ (required for SQLcl)",
    )
    table.add_row(
        "sqlcl",
        "[yellow]Optional[/yellow]",
        "managed, external",
        "Oracle SQL command-line tool",
    )
    table.add_row(
        "docker",
        "[yellow]Optional[/yellow]",
        "managed",
        "Container runtime (not auto-installed)",
    )
    table.add_row(
        "gemini-cli",
        "[yellow]Optional[/yellow]",
        "managed, external",
        "Google Gemini CLI (AI terminal assistant)",
    )
    table.add_row(
        "mcp-toolbox",
        "[yellow]Optional[/yellow]",
        "managed, external",
        "MCP Toolbox for Databases",
    )

    console.print(table)
    console.print()
    console.print("[dim]Tip: Run 'python3 manage.py install <component>' to install[/dim]")
    console.print()


@install.command(name="uv")
@click.option(
    "--version",
    help="Specific version to install (default: latest)",
)
@click.option(
    "--force",
    is_flag=True,
    help="Force reinstall even if already installed",
)
def install_uv(version: str | None, force: bool) -> None:  # noqa: PLR0915
    r"""Install Astral's UV package manager.

    Idempotent: Safe to run multiple times. Skips installation if UV is already
    installed unless --force flag is used.

    UV is a fast Python package manager and project manager.
    Required for all deployment modes.

    Installation:
    - Downloads from: https://astral.sh/uv/install.sh (Linux/Mac)
    - Installs to: ~/.local/bin or %USERPROFILE%\\.local\\bin
    - Adds to PATH if needed
    """
    console.print("[yellow]📦 Checking UV installation...[/yellow]")
    console.print()

    # ALWAYS check if already installed (not just when flag is set)
    is_installed, version_str = is_tool_installed("uv")
    if is_installed and not force:
        console.print(f"[green]✓ UV already installed: {version_str}[/green]")
        uv_path = shutil.which("uv")
        console.print(f"[dim]  Location: {uv_path}[/dim]")
        console.print("[dim]  Use --force to reinstall[/dim]")
        return

    # Proceed with installation
    if is_installed and force:
        console.print("[yellow]⚠ Reinstalling UV (--force flag used)[/yellow]")
        console.print()
    else:
        console.print("[yellow]📦 Installing UV package manager...[/yellow]")
        console.print()

    # Platform-specific installation
    if sys.platform.startswith("win"):
        console.print("[yellow]⚠ Windows installation not yet automated[/yellow]")
        console.print()
        console.print("[bold]Manual installation:[/bold]")
        console.print("  1. Visit: https://astral.sh/uv/")
        console.print("  2. Download and run the Windows installer")
        console.print("  3. Add UV to your PATH")
        return

    # Linux/macOS installation
    console.print("[cyan]Downloading UV installer...[/cyan]")

    install_cmd = "curl -LsSf https://astral.sh/uv/install.sh | sh"

    console.print(f"[dim]Running: {install_cmd}[/dim]")
    console.print()

    try:
        subprocess.run(  # noqa: S602
            install_cmd,  # Secure: curl from official source, no user input
            shell=True,
            check=True,
            text=True,
        )

        console.print()
        console.print("[green]✓ UV installed successfully![/green]")
        console.print()

        # Check if in PATH
        uv_path_after = shutil.which("uv")
        if not uv_path_after:
            console.print("[yellow]⚠ UV is not in your PATH yet[/yellow]")
            console.print()
            console.print("[bold]Add to PATH:[/bold]")

            shell = os.getenv("SHELL", "")
            if "zsh" in shell:
                console.print("  echo 'export PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.zshrc")
                console.print("  source ~/.zshrc")
            elif "bash" in shell:
                console.print("  echo 'export PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bashrc")
                console.print("  source ~/.bashrc")
            else:
                console.print("  Add $HOME/.local/bin to your PATH")
            console.print()
            console.print("[dim]Or restart your terminal[/dim]")
        else:
            console.print(f"[green]✓ UV is in PATH: {uv_path_after}[/green]")

    except subprocess.CalledProcessError as e:
        console.print(f"[red]✗ Installation failed: {e}[/red]")
        raise click.Abort from e


@install.command(name="sqlcl")
@click.option(
    "--dir",
    "install_dir",
    type=click.Path(),
    help="Installation directory (default: ~/.local/bin)",
)
@click.option(
    "--force",
    is_flag=True,
    help="Reinstall even if already installed",
)
@click.option(
    "--connection-name",
    default="cymbal_coffee",
    help="Name for saved SQLcl connection (default: cymbal_coffee)",
)
def install_sqlcl(install_dir: str | None, force: bool, connection_name: str) -> None:  # noqa: C901, PLR0915
    """Install Oracle SQLcl command-line tool.

    Idempotent: Safe to run multiple times. Skips installation if SQLcl is already
    installed unless --force flag is used.

    Optional tool for advanced Oracle database operations.
    Requires Java 11 or higher to be installed.

    IMPORTANT: SQLcl requires Java 11+. Check with 'java -version'.
    """
    from tools.oracle_deploy import cli as oracle_cli

    console.print("[yellow]📦 Checking SQLcl installation...[/yellow]")
    console.print()

    # Check for Java before proceeding
    java_path = shutil.which("java")
    if not java_path:
        console.print("[red]✗ Java not found![/red]")
        console.print()
        console.print("[bold]SQLcl requires Java 11 or higher.[/bold]")
        console.print()
        console.print("[yellow]Install Java on Ubuntu/Debian:[/yellow]")
        console.print("  [cyan]sudo apt update && sudo apt install -y default-jre[/cyan]")
        console.print()
        console.print("[yellow]Or install a specific version (Ubuntu/Debian):[/yellow]")
        console.print("  [cyan]sudo apt install openjdk-17-jre-headless[/cyan]  # Java 17 (recommended)")
        console.print("  [cyan]sudo apt install openjdk-21-jre-headless[/cyan]  # Java 21 (latest LTS)")
        console.print("  [cyan]sudo apt install openjdk-11-jre-headless[/cyan]  # Java 11 (minimum)")
        console.print()
        console.print("[yellow]RHEL/CentOS/Fedora (yum/dnf):[/yellow]")
        console.print("  [cyan]sudo yum install java-17-openjdk[/cyan]           # RHEL/CentOS 7-8")
        console.print("  [cyan]sudo dnf install java-17-openjdk[/cyan]           # RHEL/CentOS 9+, Fedora")
        console.print("  [cyan]sudo dnf install java-21-openjdk[/cyan]           # Latest LTS")
        console.print()
        console.print("[yellow]Other platforms:[/yellow]")
        console.print("  • macOS: [cyan]brew install openjdk@17[/cyan]")
        console.print("  • Download from: [dim]https://adoptium.net/[/dim]")
        console.print()
        console.print("[dim]After installing Java, run this command again.[/dim]")
        raise click.Abort

    # Check Java version
    returncode, _stdout, _ = run_command(["java", "-version"], check=False)
    if returncode == 0:
        console.print("[green]✓ Java found[/green]")
        console.print()

    # Check if already installed
    is_installed, version_str = is_tool_installed("sql", "-V")
    if is_installed and not force:
        console.print(f"[green]✓ SQLcl already installed: {version_str.split(chr(10))[0]}[/green]")
        sqlcl_path = shutil.which("sql")
        console.print(f"[dim]  Location: {sqlcl_path}[/dim]")
        console.print("[dim]  Use --force to reinstall[/dim]")

        # Still check for Gemini MCP configuration
        gemini_path = shutil.which("gemini")
        if gemini_path:
            console.print()
            console.print("[yellow]🔐 Checking Gemini MCP integration...[/yellow]")

            # Check if already configured
            if is_mcp_server_configured("sqlcl"):
                console.print("[green]✓ SQLcl MCP server already configured[/green]")
            else:
                console.print("[yellow]🔐 Configuring SQLcl for Gemini MCP...[/yellow]")

                # Step 1: Configure saved connection with password
                success, message = configure_sqlcl_connection_with_password(connection_name)
                if success:
                    console.print(f"[green]✓ {message}[/green]")
                else:
                    console.print(f"[yellow]⚠ Password configuration: {message}[/yellow]")

                # Step 2: Configure Gemini MCP server
                if configure_gemini_mcp_sqlcl():
                    console.print("[green]✓ Configured SQLcl as Gemini MCP server[/green]")

        return

    # If force flag, show warning
    if is_installed and force:
        console.print("[yellow]⚠ Reinstalling SQLcl (--force flag used)[/yellow]")
        console.print()

    console.print("[yellow]📦 Installing Oracle SQLcl...[/yellow]")
    console.print()

    # Delegate to existing implementation
    args = ["sqlcl", "install"]
    if install_dir:
        args.extend(["--dir", install_dir])
    if force:
        args.append("--force")

    click.get_current_context()
    with contextlib.suppress(SystemExit):  # Click may raise SystemExit(0)
        oracle_cli.main(args, standalone_mode=False)

    # Post-installation instructions
    console.print()
    console.print("[bold]Test SQLcl:[/bold]")
    console.print("  [cyan]sql -V[/cyan]")
    console.print()
    console.print("[dim]Note: Make sure ~/.local/bin is in your PATH[/dim]")

    # Configure Gemini MCP integration if Gemini CLI is installed
    gemini_path = shutil.which("gemini")
    if gemini_path:
        console.print()
        console.print("[yellow]🔐 Configuring SQLcl MCP integration...[/yellow]")

        # Step 1: Configure saved connection with password
        success, message = configure_sqlcl_connection_with_password(connection_name)
        if success:
            console.print(f"[green]✓ {message}[/green]")
        else:
            console.print(f"[yellow]⚠ Password configuration: {message}[/yellow]")
            console.print(
                "[dim]  Ensure .env has DATABASE_USER, DATABASE_PASSWORD, DATABASE_HOST, DATABASE_SERVICE_NAME[/dim]"
            )

        # Step 2: Configure Gemini MCP server
        if configure_gemini_mcp_sqlcl():
            console.print("[green]✓ Configured SQLcl as Gemini MCP server[/green]")
            if success:
                console.print("[dim]  SQLcl is now fully configured for MCP access[/dim]")
            else:
                console.print("[dim]  Note: Password still needs to be configured[/dim]")
        else:
            console.print("[yellow]⚠ Could not auto-configure Gemini MCP[/yellow]")
            console.print("[dim]  You can manually add SQLcl to ~/.gemini/settings.json[/dim]")


@install.command(name="gemini-cli")
@click.option(
    "--force",
    is_flag=True,
    help="Force reinstall even if already installed",
)
@click.option(
    "--configure-mcp",
    is_flag=True,
    default=True,
    help="Configure MCP extensions (default: True)",
)
def install_gemini_cli(force: bool, configure_mcp: bool) -> None:  # noqa: C901, PLR0915
    """Install Google Gemini CLI.

    Idempotent: Safe to run multiple times. Skips installation if Gemini CLI is
    already installed unless --force flag is used.

    AI-powered terminal assistant with access to Gemini 2.5 Pro.
    Requires Node.js 18 or higher.

    Features:
    - Free tier: 60 requests/min, 1000 requests/day
    - 1M token context window
    - Built-in tools: Google Search, file ops, shell commands
    """
    console.print("[yellow]📦 Checking Gemini CLI installation...[/yellow]")
    console.print()

    # ALWAYS check if already installed
    is_installed, version_str = is_tool_installed("gemini")
    if is_installed and not force:
        console.print(f"[green]✓ Gemini CLI already installed: {version_str}[/green]")
        gemini_path = shutil.which("gemini")
        console.print(f"[dim]  Location: {gemini_path}[/dim]")
        console.print("[dim]  Use --force to reinstall[/dim]")

        # Still check for MCP configuration
        if configure_mcp:
            console.print()
            console.print("[yellow]🔧 Checking MCP configuration...[/yellow]")
            _configure_missing_mcp_extensions()

        return

    # Check for Node.js
    node_path = shutil.which("node")
    if not node_path:
        console.print("[red]✗ Node.js not found![/red]")
        console.print()
        console.print("[bold]Gemini CLI requires Node.js 18 or higher.[/bold]")
        console.print()
        console.print("[yellow]Install Node.js on Ubuntu/Debian:[/yellow]")
        console.print("  [cyan]curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -[/cyan]")
        console.print("  [cyan]sudo apt-get install -y nodejs[/cyan]")
        console.print()
        console.print("[yellow]RHEL/CentOS/Fedora:[/yellow]")
        console.print("  [cyan]curl -fsSL https://rpm.nodesource.com/setup_20.x | sudo bash -[/cyan]")
        console.print("  [cyan]sudo yum install -y nodejs[/cyan]  # or dnf")
        console.print()
        console.print("[yellow]Other platforms:[/yellow]")
        console.print("  • macOS: [cyan]brew install node@20[/cyan]")
        console.print("  • Download from: [dim]https://nodejs.org/[/dim]")
        console.print()
        raise click.Abort

    # Check Node.js version
    returncode, stdout, _ = run_command(["node", "--version"], check=False)
    if returncode == 0:
        version = stdout.strip()
        console.print(f"[green]✓ Node.js found: {version}[/green]")
        console.print()

    # Install via npm
    console.print("[cyan]Installing via npm...[/cyan]")
    console.print("[dim]Running: npm install -g @google/gemini-cli[/dim]")
    console.print()

    try:
        subprocess.run(
            ["npm", "install", "-g", "@google/gemini-cli"],  # noqa: S607
            check=True,
            text=True,
        )

        console.print()
        console.print("[green]✓ Gemini CLI installed successfully![/green]")
        console.print()

        # Configure popular MCP extensions
        console.rule("[bold cyan]MCP Extensions Configuration", style="cyan", align="left")
        console.print()
        console.print("[bold]Gemini CLI supports MCP (Model Context Protocol) extensions.[/bold]")
        console.print("These extensions enhance Gemini with additional capabilities.")
        console.print()

        # Check if SQLcl is installed and configure if available
        sqlcl_path = shutil.which("sql")
        sqlcl_configured = False
        if sqlcl_path:
            console.print()
            console.print("[bold cyan]SQLcl (Oracle Database)[/bold cyan]")
            console.print("[dim]Oracle database operations and SQL execution[/dim]")
            if Confirm.ask("Configure SQLcl MCP server?", default=True):
                # Step 1: Configure saved connection with password
                success, message = configure_sqlcl_connection_with_password()
                if success:
                    console.print(f"[green]✓[/green] {message}")
                else:
                    console.print(f"[yellow]⚠[/yellow] Password config: {message}")
                    console.print(
                        "[dim]  Ensure .env has DATABASE_USER, DATABASE_PASSWORD, DATABASE_HOST, DATABASE_SERVICE_NAME[/dim]"
                    )

                # Step 2: Configure Gemini MCP server
                if configure_gemini_mcp_sqlcl():
                    console.print("[green]✓[/green] SQLcl MCP server configured")
                    sqlcl_configured = True
                else:
                    console.print("[red]✗[/red] Failed to configure SQLcl MCP server")

        results = configure_gemini_mcp_extensions(interactive=True)

        # Show configuration results
        console.print()
        console.print("[bold]MCP Configuration Summary:[/bold]")
        if sqlcl_configured:
            console.print("  [green]✓[/green] sqlcl (Oracle Database)")
        for key, success in results.items():
            if success:
                console.print(f"  [green]✓[/green] {key}")
            else:
                console.print(f"  [dim]⊘ {key} (skipped)[/dim]")

        console.print()
        console.print("[bold]First run:[/bold]")
        console.print("  [cyan]gemini[/cyan]  # Launch interactive CLI")
        console.print()
        console.print("[bold]Authentication:[/bold]")
        console.print("  • Login with Google (free tier)")
        console.print("  • Or use API key from Google AI Studio")
        console.print()
        console.print("[dim]Learn more: https://github.com/google-gemini/gemini-cli[/dim]")

    except subprocess.CalledProcessError as e:
        console.print(f"[red]✗ Installation failed: {e}[/red]")
        raise click.Abort from e


@install.command(name="mcp-toolbox")
@click.option(
    "--force",
    is_flag=True,
    help="Force reinstall even if already installed",
)
@click.option(
    "--version",
    default="v0.16.0",
    help="Specific version to install (default: v0.16.0)",
)
def install_mcp_toolbox(force: bool, version: str) -> None:  # noqa: PLR0915
    """Install MCP Toolbox for Databases.

    Idempotent: Safe to run multiple times. Skips installation if MCP Toolbox
    is already installed unless --force flag is used.

    Open-source MCP server for databases (AlloyDB, Spanner, Cloud SQL, etc.)
    Requires Go 1.21 or higher for installation from source.

    Binary downloads available for Linux, macOS (Intel/ARM), and Windows.
    """
    console.print("[yellow]📦 Checking MCP Toolbox installation...[/yellow]")
    console.print()

    # ALWAYS check if already installed
    is_installed, _version_str = is_tool_installed("toolbox")
    if is_installed and not force:
        console.print("[green]✓ MCP Toolbox already installed[/green]")
        toolbox_path = shutil.which("toolbox")
        console.print(f"[dim]  Location: {toolbox_path}[/dim]")
        console.print("[dim]  Use --force to reinstall[/dim]")
        return

    # If force flag, show warning
    if is_installed and force:
        console.print("[yellow]⚠ Reinstalling MCP Toolbox (--force flag used)[/yellow]")
        console.print()

    console.print("[yellow]📦 Installing MCP Toolbox for Databases...[/yellow]")
    console.print()

    # Detect platform
    import platform

    system = platform.system().lower()
    machine = platform.machine().lower()

    # Map to download OS/arch
    if (system == "linux" and "x86_64" in machine) or "amd64" in machine:
        os_arch = "linux/amd64"
    elif system == "darwin" and ("arm64" in machine or "aarch64" in machine):
        os_arch = "darwin/arm64"
    elif system == "darwin":
        os_arch = "darwin/amd64"
    elif system == "windows":
        os_arch = "windows/amd64"
    else:
        console.print(f"[red]✗ Unsupported platform: {system}/{machine}[/red]")
        raise click.Abort

    console.print(f"[cyan]Detected platform: {os_arch}[/cyan]")
    console.print()

    # Download binary
    download_url = f"https://storage.googleapis.com/genai-toolbox/{version}/{os_arch}/toolbox"
    install_path = Path.home() / ".local" / "bin" / "toolbox"

    console.print(f"[cyan]Downloading from: {download_url}[/cyan]")
    console.print()

    try:
        import httpx

        with httpx.stream("GET", download_url, follow_redirects=True, timeout=60) as response:
            response.raise_for_status()

            # Create install directory
            install_path.parent.mkdir(parents=True, exist_ok=True)

            # Download file
            with install_path.open("wb") as f:
                f.writelines(response.iter_bytes(chunk_size=8192))

        # Make executable
        install_path.chmod(0o755)

        console.print(f"[green]✓ MCP Toolbox installed to {install_path}[/green]")
        console.print()
        console.print("[bold]Verify installation:[/bold]")
        console.print("  [cyan]toolbox --version[/cyan]")
        console.print()
        console.print("[bold]Supported databases:[/bold]")
        console.print("  • AlloyDB for PostgreSQL (including AlloyDB Omni)")
        console.print("  • Cloud SQL (PostgreSQL, MySQL, SQL Server)")
        console.print("  • Spanner, Bigtable")
        console.print("  • Self-managed MySQL and PostgreSQL")
        console.print()
        console.print("[dim]Learn more: https://googleapis.github.io/genai-toolbox/[/dim]")

    except Exception as e:
        console.print(f"[red]✗ Installation failed: {e}[/red]")
        console.print()
        console.print("[yellow]Alternative: Install via Go[/yellow]")
        console.print(f"  [cyan]go install github.com/googleapis/genai-toolbox@{version}[/cyan]")
        raise click.Abort from e


# ============================================================================
# DOCTOR COMMAND - Prerequisites Verification
# ============================================================================


@cli.command()
@click.option(
    "--mode",
    type=click.Choice(["managed", "external"], case_sensitive=False),
    help="Check prerequisites for specific mode (auto-detect if not specified)",
)
@click.option(
    "--json",
    "json_output",
    is_flag=True,
    help="Output results as JSON",
)
@click.option(
    "--verbose",
    "-v",
    is_flag=True,
    help="Show detailed diagnostic information",
)
def doctor(mode: str | None, json_output: bool, verbose: bool) -> None:  # noqa: C901, PLR0915
    """Verify all prerequisites and configuration.

    Checks:
    - .env file exists and is valid
    - UV package manager installed
    - Mode-specific requirements (Docker for managed, wallet if configured)
    - Database connectivity (optional)

    Exit codes:
    - 0: All checks passed
    - 1: One or more checks failed
    """

    if mode is None:
        mode = detect_deployment_mode()

    if not json_output:
        console.rule(f"[bold blue]Health Check for '{mode}' Mode", style="blue")
        console.print()

    checks = {
        "env_file": False,
        "uv_installed": False,
        "mode_specific": {},
        "overall": False,
    }

    # Check .env file
    if not json_output:
        console.print("[yellow]📄 Checking .env file...[/yellow]")

    checks["env_file"] = check_env_file()
    if not json_output:
        if checks["env_file"]:
            console.print("[green]✓ .env file exists[/green]")
        else:
            console.print("[red]✗ .env file not found[/red]")
            console.print("[dim]  Run: python manage.py init[/dim]")

    # Check UV
    if not json_output:
        console.print("[yellow]📦 Checking UV package manager...[/yellow]")

    uv_path = shutil.which("uv")
    checks["uv_installed"] = uv_path is not None

    if not json_output:
        if checks["uv_installed"]:
            returncode, stdout, _ = run_command(["uv", "--version"], check=False)
            version = stdout.strip() if returncode == 0 else "unknown"
            console.print(f"[green]✓ UV installed: {version}[/green]")
            if verbose:
                console.print(f"[dim]  Location: {uv_path}[/dim]")
        else:
            console.print("[red]✗ UV not found[/red]")
            console.print("[dim]  Run: python manage.py install uv[/dim]")

    # Mode-specific checks
    if not json_output:
        console.print(f"[yellow]🔧 Checking '{mode}' mode prerequisites...[/yellow]")

    mode_specific: dict[str, bool] = {}

    if mode == "managed":
        # Check Docker/Podman
        has_docker = shutil.which("docker") is not None
        has_podman = shutil.which("podman") is not None
        mode_specific["container_runtime"] = has_docker or has_podman

        if not json_output:
            if has_docker:
                console.print("[green]✓ Docker found[/green]")
            elif has_podman:
                console.print("[green]✓ Podman found[/green]")
            else:
                console.print("[red]✗ Neither Docker nor Podman found[/red]")
                console.print("[dim]  Install from: https://www.docker.com/get-started[/dim]")

    elif mode == "external":
        # Check wallet location (if configured - wallet is optional for external)
        wallet_location = os.getenv("WALLET_LOCATION") or os.getenv("TNS_ADMIN")
        if wallet_location:
            mode_specific["wallet_configured"] = True
            wallet_path = Path(wallet_location)
            mode_specific["wallet_exists"] = wallet_path.exists()

            if wallet_path.exists():
                cwallet = wallet_path / "cwallet.sso"
                tnsnames = wallet_path / "tnsnames.ora"
                mode_specific["wallet_valid"] = cwallet.exists() and tnsnames.exists()
            else:
                mode_specific["wallet_valid"] = False

            if not json_output:
                console.print(f"[green]✓ Wallet location configured: {wallet_location}[/green]")
                if mode_specific.get("wallet_exists"):
                    console.print("[green]✓ Wallet directory exists[/green]")
                    if mode_specific.get("wallet_valid"):
                        console.print("[green]✓ Wallet files valid[/green]")
                    else:
                        console.print("[red]✗ Wallet missing required files[/red]")
                else:
                    console.print("[red]✗ Wallet directory not found[/red]")
        # Wallet not configured - this is OK for external mode
        elif not json_output:
            console.print("[dim]i No wallet configured (using standard connection)[/dim]")

    checks["mode_specific"] = mode_specific
    # Overall status - ensure we have bool values
    env_file_check = bool(checks.get("env_file", False))
    uv_check = bool(checks.get("uv_installed", False))
    mode_checks = all(mode_specific.values()) if mode_specific else True
    checks["overall"] = env_file_check and uv_check and mode_checks

    # Output results
    if json_output:
        import json as json_module

        console.print(json_module.dumps(checks, indent=2))
    else:
        console.print()
        if checks["overall"]:
            console.print("[bold green]✓ All checks passed![/bold green]")
            console.print()
            console.print("[bold]Next steps:[/bold]")
            console.print("  • Run [cyan]python manage.py connect test[/cyan] to verify database connection")
            console.print("  • Run [cyan]uv run app run[/cyan] to start the application")
        else:
            console.print("[bold red]✗ Some checks failed[/bold red]")
            console.print()
            console.print("[bold]To fix:[/bold]")
            if not checks["env_file"]:
                console.print("  • Run [cyan]python manage.py init[/cyan]")
            if not checks["uv_installed"]:
                console.print("  • Run [cyan]python manage.py install uv[/cyan]")
            mode_specific_dict = checks.get("mode_specific", {})
            if isinstance(mode_specific_dict, dict) and not all(mode_specific_dict.values()):
                console.print("  • Check mode-specific requirements above")

    if not checks["overall"]:
        raise click.Abort


# ============================================================================
# PROXY COMMANDS - Delegate to tools/oracle_deploy.py
# ============================================================================


@cli.group(name="database")
def database_group() -> None:
    """Manage database operations.

    Commands for database management across different providers.
    """


@database_group.group(name="oracle")
def oracle_group() -> None:
    """Manage Oracle database operations.

    Commands for deploying and managing Oracle databases, wallets, and connections.
    Requires Docker or Podman for managed mode.
    """


@oracle_group.command(name="start-local-container")
@click.option("--pull", is_flag=True, help="Pull latest image before starting")
@click.option("--recreate", is_flag=True, help="Remove and recreate container if exists")
def oracle_start(pull: bool, recreate: bool) -> None:
    """Start Oracle database container."""
    from tools.oracle_deploy import cli as oracle_cli

    args = ["database", "start"]
    if pull:
        args.append("--pull")
    if recreate:
        args.append("--recreate")

    with contextlib.suppress(SystemExit):
        oracle_cli.main(args, standalone_mode=False)


@oracle_group.command(name="stop-local-container")
@click.option("--timeout", default=30, help="Seconds to wait before forcing stop")
def oracle_stop(timeout: int) -> None:
    """Stop Oracle database container."""
    from tools.oracle_deploy import cli as oracle_cli

    with contextlib.suppress(SystemExit):
        oracle_cli.main(["database", "stop", "--timeout", str(timeout)], standalone_mode=False)


@oracle_group.command(name="status")
@click.option("--verbose", "-v", is_flag=True, help="Show detailed status")
def oracle_status(verbose: bool) -> None:
    """Check database container status."""
    from tools.oracle_deploy import cli as oracle_cli

    args = ["database", "status"]
    if verbose:
        args.append("--verbose")

    with contextlib.suppress(SystemExit):
        oracle_cli.main(args, standalone_mode=False)


@oracle_group.command(name="local-container-logs")
@click.option("--follow", "-f", is_flag=True, help="Follow log output")
@click.option("--tail", default=50, help="Number of lines to show from end of logs")
def oracle_logs(follow: bool, tail: int) -> None:
    """View database container logs."""
    from tools.oracle_deploy import cli as oracle_cli

    args = ["database", "logs", "--tail", str(tail)]
    if follow:
        args.append("--follow")

    with contextlib.suppress(SystemExit):
        oracle_cli.main(args, standalone_mode=False)


@oracle_group.command(name="wipe-local-container")
@click.option("--volumes", is_flag=True, help="Remove volumes as well")
@click.option("--force", is_flag=True, help="Force removal without confirmation")
def oracle_remove(volumes: bool, force: bool) -> None:
    """Remove Oracle database container."""
    from tools.oracle_deploy import cli as oracle_cli

    args = ["database", "remove"]
    if volumes:
        args.append("--volumes")
    if force:
        args.append("--force")

    with contextlib.suppress(SystemExit):
        oracle_cli.main(args, standalone_mode=False)


@oracle_group.group(name="wallet")
def wallet_group() -> None:
    """Manage Autonomous Database wallets.

    Extract, configure, and validate Oracle Autonomous Database wallet files.
    """


@wallet_group.command(name="extract")
@click.argument("wallet_zip", type=click.Path(exists=True))
@click.option("--dest", type=click.Path(), help="Destination directory (default: .envs/tns)")
def wallet_extract(wallet_zip: str, dest: str | None) -> None:
    """Extract wallet zip file."""
    from tools.oracle_deploy import cli as oracle_cli

    args = ["wallet", "extract", wallet_zip]
    if dest:
        args.extend(["--dest", dest])

    with contextlib.suppress(SystemExit):
        oracle_cli.main(args, standalone_mode=False)


@wallet_group.command(name="configure")
@click.option("--wallet-dir", type=click.Path(exists=True), help="Wallet directory")
@click.option("--non-interactive", is_flag=True, help="Skip interactive prompts")
def wallet_configure(wallet_dir: str | None, non_interactive: bool) -> None:
    """Interactive wallet configuration wizard."""
    from tools.oracle_deploy import cli as oracle_cli

    args = ["wallet", "configure"]
    if wallet_dir:
        args.extend(["--wallet-dir", wallet_dir])
    if non_interactive:
        args.append("--non-interactive")

    with contextlib.suppress(SystemExit):
        oracle_cli.main(args, standalone_mode=False)


@oracle_group.group(name="connect")
def connect_group() -> None:
    """Test database connections.

    Test connectivity to Oracle databases in any deployment mode.
    """


@connect_group.command(name="test")
@click.option(
    "--mode",
    type=click.Choice(["managed", "external"]),
    help="Deployment mode (auto-detect if not specified)",
)
@click.option("--timeout", default=10, help="Connection timeout in seconds")
def connect_test(mode: str | None, timeout: int) -> None:
    """Test database connection."""
    from tools.oracle_deploy import cli as oracle_cli

    args = ["connect", "test", "--timeout", str(timeout)]
    if mode:
        args.extend(["--mode", mode])

    with contextlib.suppress(SystemExit):
        oracle_cli.main(args, standalone_mode=False)


@cli.command(name="status")
@click.option("--verbose", "-v", is_flag=True, help="Show detailed diagnostics")
@click.option(
    "--mode",
    type=click.Choice(["managed", "external"]),
    help="Check specific deployment mode",
)
def status(verbose: bool, mode: str | None) -> None:
    """Check overall system health.

    Comprehensive health check of all deployment components:
    - Container runtime (Docker/Podman)
    - Database container (if managed)
    - SQLcl installation
    - Wallet configuration (if configured)
    - Database connectivity
    """
    from tools.oracle_deploy import cli as oracle_cli

    args = ["status"]
    if verbose:
        args.append("--verbose")
    if mode:
        args.extend(["--mode", mode])

    with contextlib.suppress(SystemExit):
        oracle_cli.main(args, standalone_mode=False)


# ============================================================================
# Main Entry Point
# ============================================================================


def main() -> None:
    """Main entry point."""
    try:
        cli()
    except KeyboardInterrupt:
        console.print("\n[yellow]Interrupted by user[/yellow]")
        sys.exit(130)
    except Exception as e:  # noqa: BLE001
        console.print(f"[red]Error: {e}[/red]")
        sys.exit(1)


if __name__ == "__main__":
    main()
