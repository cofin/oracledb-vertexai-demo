#!/usr/bin/env python3
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "httpx>=0.28.1",
#     "rich>=13.9.4",
#     "rich-click>=1.8.0",
#     "oracledb>=2.0.0",
#     "python-dotenv>=1.0.0",
# ]
# ///
"""Unified project management CLI for Oracle + Vertex AI demo.

This tool provides a single interface for:
- Project initialization and environment setup
- Prerequisite installation (UV, SQLcl, etc.)
- Oracle database deployment (managed container or external connection)
- Wallet configuration and validation (auto-detected)
- Connection testing and health checks

IMPORTANT: This is a development tool and should not be shipped with production code.

Usage:
    python manage.py init                  # Initialize project
    python manage.py install all          # Install all prerequisites
    python manage.py doctor               # Verify setup
    python manage.py database start       # Start Oracle container
    python manage.py --help               # Show all commands
"""

from __future__ import annotations

import os
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Any

import rich_click as click
from rich.console import Console
from rich.prompt import Confirm, Prompt
from rich.table import Table

# Ensure tools package is importable
sys.path.insert(0, str(Path(__file__).parent))

console = Console()

# Configure rich-click
click.rich_click.USE_RICH_MARKUP = True
click.rich_click.SHOW_ARGUMENTS = True
click.rich_click.GROUP_ARGUMENTS_OPTIONS = True
click.rich_click.STYLE_ERRORS_SUGGESTION = "yellow italic"
click.rich_click.ERRORS_SUGGESTION = "Try running the '--help' flag for more information."


# ============================================================================
# Utility Functions
# ============================================================================


def detect_deployment_mode() -> str:
    """Detect deployment mode from environment.

    Returns:
        str: "managed" or "external"

    Detection logic:
        - If DATABASE_HOST or DATABASE_URL is set -> external
        - Otherwise -> managed (Docker container we control)

    Wallet detection is automatic - if TNS_ADMIN/WALLET_LOCATION is set,
    wallet-based connection will be used regardless of mode.
    """
    if os.getenv("DATABASE_HOST") or os.getenv("DATABASE_URL"):
        return "external"
    return "managed"


def check_env_file() -> bool:
    """Check if .env file exists."""
    return Path(".env").exists()


def generate_secret_key() -> str:
    """Generate a secure random secret key."""
    import secrets

    return secrets.token_hex(32)


def create_env_interactive(mode: str, non_interactive: bool = False) -> bool:
    """Create .env file interactively based on deployment mode.

    Args:
        mode: Deployment mode ("managed" or "external")
        non_interactive: If True, use defaults without prompting

    Returns:
        bool: True if successful, False otherwise
    """
    env_path = Path(".env")

    if env_path.exists():
        console.print("[yellow]⚠ .env already exists[/yellow]")
        if not non_interactive:
            overwrite = Confirm.ask("Overwrite existing .env?", default=False)
            if not overwrite:
                console.print("[cyan]Keeping existing .env[/cyan]")
                return True

    console.print(f"[bold]Creating .env for [cyan]{mode}[/cyan] mode...[/bold]")
    console.print()

    # Core application settings (always required)
    default_secret = generate_secret_key()
    if non_interactive:
        secret_key = default_secret
        google_project = "demo-project"
        google_api_key = ""
    else:
        console.print("[bold]Core Application Settings:[/bold]")
        secret_key = Prompt.ask("SECRET_KEY (press Enter to auto-generate)", default=default_secret, show_default=False)
        console.print()

        console.print("[bold]Google Cloud / Vertex AI Settings:[/bold]")
        google_project = Prompt.ask("GOOGLE_CLOUD_PROJECT", default="demo-project")
        google_api_key = Prompt.ask("GOOGLE_API_KEY (optional)", default="")

    env_content = "# Application Configuration\n"
    env_content += "# Generated by: python manage.py init\n\n"

    # Database configuration based on mode
    if mode == "managed":
        # Managed mode: container with known defaults
        if non_interactive:
            db_user = "app"
            db_password = "super-secret"
            db_host = "localhost"
            db_port = "1521"
            db_service = "freepdb1"
        else:
            console.print("[bold]Database Settings (Managed Container):[/bold]")
            db_user = Prompt.ask("DATABASE_USER", default="app")
            db_password = Prompt.ask("DATABASE_PASSWORD", default="super-secret")
            db_host = Prompt.ask("DATABASE_HOST", default="localhost")
            db_port = Prompt.ask("DATABASE_PORT", default="1521")
            db_service = Prompt.ask("DATABASE_SERVICE_NAME", default="freepdb1")

        env_content += "# Database (Managed Container)\n"
        env_content += f"DATABASE_USER={db_user}\n"
        env_content += f"DATABASE_PASSWORD={db_password}\n"
        env_content += f"DATABASE_HOST={db_host}\n"
        env_content += f"DATABASE_PORT={db_port}\n"
        env_content += f"DATABASE_SERVICE_NAME={db_service}\n\n"

    elif non_interactive:
        use_wallet = False
        db_user = "app"
        db_password = "your-password"
        db_host = "your-oracle-host"
        db_port = "1521"
        db_service = "your-service-name"
    else:
        console.print("[bold]External Database Connection:[/bold]")
        use_wallet = Confirm.ask("Use wallet-based connection (Autonomous DB, mTLS)?", default=False)

        if use_wallet:
            console.print("[dim]Using DATABASE_URL format for wallet connections[/dim]")
            db_url = Prompt.ask("DATABASE_URL", default="oracle+oracledb://ADMIN:password@service_high")
            wallet_password = Prompt.ask("WALLET_PASSWORD", default="")
            wallet_location = Prompt.ask("WALLET_LOCATION/TNS_ADMIN", default="./.envs/tns")

            env_content += "# Database (External - Wallet/Autonomous)\n"
            env_content += f"DATABASE_URL={db_url}\n"
            if wallet_password:
                env_content += f"WALLET_PASSWORD={wallet_password}\n"
            env_content += f"TNS_ADMIN={wallet_location}\n\n"
        else:
            console.print("[dim]Using standard connection parameters[/dim]")
            db_user = Prompt.ask("DATABASE_USER", default="app")
            db_password = Prompt.ask("DATABASE_PASSWORD", default="your-password")
            db_host = Prompt.ask("DATABASE_HOST", default="your-oracle-host")
            db_port = Prompt.ask("DATABASE_PORT", default="1521")
            db_service = Prompt.ask("DATABASE_SERVICE_NAME", default="your-service-name")

            env_content += "# Database (External - Standard)\n"
            env_content += f"DATABASE_USER={db_user}\n"
            env_content += f"DATABASE_PASSWORD={db_password}\n"
            env_content += f"DATABASE_HOST={db_host}\n"
            env_content += f"DATABASE_PORT={db_port}\n"
            env_content += f"DATABASE_SERVICE_NAME={db_service}\n\n"

    # Google Cloud settings
    env_content += "# Google Cloud / Vertex AI\n"
    env_content += f"GOOGLE_CLOUD_PROJECT={google_project}\n"
    if google_api_key:
        env_content += f"GOOGLE_API_KEY={google_api_key}\n"
    env_content += "\n"

    # Server settings
    env_content += "# Server Configuration\n"
    env_content += "LITESTAR_DEBUG=true\n"
    env_content += "LITESTAR_HOST=0.0.0.0\n"
    env_content += "LITESTAR_PORT=5006\n"
    env_content += "LITESTAR_GRANIAN_IN_SUBPROCESS=false\n"
    env_content += "LITESTAR_GRANIAN_USE_LITESTAR_LOGGER=true\n"
    env_content += f"SECRET_KEY={secret_key}\n\n"

    # Development settings
    env_content += "# Development (optional)\n"
    env_content += "# VITE_HOST=localhost\n"
    env_content += "# VITE_PORT=51745\n"
    env_content += "# VITE_HOT_RELOAD=False\n"
    env_content += "# VITE_DEV_MODE=False\n"

    try:
        env_path.write_text(env_content)
        console.print("[green]✓ Created .env file[/green]")
        return True
    except Exception as e:
        console.print(f"[red]✗ Failed to create .env: {e}[/red]")
        return False


def run_command(cmd: list[str], check: bool = True) -> tuple[int, str, str]:
    """Run shell command and return exit code, stdout, stderr."""
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=check,
        )
        return result.returncode, result.stdout, result.stderr
    except subprocess.CalledProcessError as e:
        return e.returncode, e.stdout, e.stderr
    except Exception as e:
        return 1, "", str(e)


def configure_sqlcl_connection_with_password(connection_name: str = "mcp_demo") -> tuple[bool, str]:
    """Configure SQLcl saved connection with password from .env.

    Args:
        connection_name: Name for the saved connection (default: mcp_demo)

    Returns:
        tuple[bool, str]: Success status and message

    SQLcl MCP requires a saved connection with password using the -savepwd flag.
    This function creates a saved connection using credentials from .env.

    Command format:
        conn -save <name> -savepwd username/password@//host:port/service
    """
    from dotenv import dotenv_values

    # Load .env values
    env_path = Path(".env")
    if not env_path.exists():
        return False, ".env file not found - run 'python manage.py init' first"

    env_vars = dotenv_values(env_path)

    # Get connection parameters
    user = env_vars.get("DATABASE_USER")
    password = env_vars.get("DATABASE_PASSWORD")
    host = env_vars.get("DATABASE_HOST")
    port = env_vars.get("DATABASE_PORT", "1521")
    service_name = env_vars.get("DATABASE_SERVICE_NAME")

    # Validate required parameters
    if not user:
        return False, "DATABASE_USER not configured in .env"
    if not password:
        return False, "DATABASE_PASSWORD not configured in .env"
    if not host:
        return False, "DATABASE_HOST not configured in .env"
    if not service_name:
        return False, "DATABASE_SERVICE_NAME not configured in .env"

    # Check if SQLcl is installed
    if not shutil.which("sql"):
        return False, "SQLcl not found in PATH - run 'python manage.py install sqlcl' first"

    # Build connection string (Oracle format with //)
    conn_string = f"{user}/{password}@//{host}:{port}/{service_name}"

    # Use echo to pipe the connection command
    conn_cmd = f"conn -save {connection_name} -savepwd {conn_string}\nexit"

    try:
        result = subprocess.run(
            ["sql", "/nolog"],
            check=False,
            input=conn_cmd,
            capture_output=True,
            text=True,
            timeout=10,
        )

        # Check if successful
        if result.returncode == 0:
            return True, f"Saved connection '{connection_name}' configured for {user}@//{host}:{port}/{service_name}"
        error_msg = result.stderr or result.stdout
        return False, f"Failed to save connection: {error_msg}"

    except subprocess.TimeoutExpired:
        return False, "SQLcl command timed out"
    except Exception as e:
        return False, f"Error running SQLcl: {e}"


def configure_gemini_mcp_sqlcl() -> bool:
    """Configure SQLcl as a Gemini MCP server.

    Returns:
        bool: True if configuration was successful, False otherwise

    Adds or updates SQLcl MCP server configuration in ~/.gemini/settings.json.
    Configuration format:
    {
        "mcpServers": {
            "sqlcl": {
                "command": "sql",
                "args": ["-mcp"]
            }
        }
    }
    """
    import json

    gemini_settings_path = Path.home() / ".gemini" / "settings.json"

    # Check if Gemini settings directory exists
    if not gemini_settings_path.parent.exists():
        try:
            gemini_settings_path.parent.mkdir(parents=True, exist_ok=True)
        except Exception:
            return False

    # Read existing settings or create new
    settings: dict[str, Any] = {}
    if gemini_settings_path.exists():
        try:
            with open(gemini_settings_path) as f:
                settings = json.load(f)
        except Exception:
            return False

    # Ensure mcpServers key exists
    if "mcpServers" not in settings:
        settings["mcpServers"] = {}

    # Add or update SQLcl configuration
    settings["mcpServers"]["sqlcl"] = {"command": "sql", "args": ["-mcp"]}

    # Write back to file
    try:
        with open(gemini_settings_path, "w") as f:
            json.dump(settings, f, indent=2)
        return True
    except Exception:
        return False


def configure_gemini_mcp_extensions(interactive: bool = True) -> dict[str, bool]:
    """Configure popular Gemini MCP extensions.

    Args:
        interactive: If True, prompt user for each extension

    Returns:
        dict: Status of each extension configuration {extension_name: success}

    Configures:
    - sequential-thinking: Advanced reasoning capabilities
    - context7: Documentation and code context from popular libraries
    """
    import json

    gemini_settings_path = Path.home() / ".gemini" / "settings.json"
    results = {}

    # Check if Gemini settings directory exists
    if not gemini_settings_path.parent.exists():
        try:
            gemini_settings_path.parent.mkdir(parents=True, exist_ok=True)
        except Exception:
            return {"error": False}

    # Read existing settings or create new
    settings: dict[str, Any] = {}
    if gemini_settings_path.exists():
        try:
            with open(gemini_settings_path) as f:
                settings = json.load(f)
        except Exception:
            return {"error": False}

    # Ensure mcpServers key exists
    if "mcpServers" not in settings:
        settings["mcpServers"] = {}

    # Define extensions
    extensions = {
        "sequential-thinking": {
            "name": "Sequential Thinking",
            "description": "Advanced reasoning with step-by-step problem solving",
            "config": {
                "type": "stdio",
                "command": "npx",
                "args": ["-y", "@modelcontextprotocol/server-sequential-thinking"],
            },
        },
        "context7": {
            "name": "Context7",
            "description": "Documentation lookup for popular libraries and frameworks",
            "config": {"command": "npx", "args": ["-y", "@upstash/context7-mcp"]},
        },
    }

    # Configure each extension
    for key, ext in extensions.items():
        # Check if already configured
        if key in settings["mcpServers"]:
            results[key] = True  # Already exists, consider it a success
            continue

        # Interactive prompt
        should_install = True
        if interactive:
            console.print()
            console.print(f"[bold cyan]{ext['name']}[/bold cyan]")
            console.print(f"[dim]{ext['description']}[/dim]")
            should_install = Confirm.ask(f"Configure {ext['name']}?", default=True)

        if should_install:
            settings["mcpServers"][key] = ext["config"]
            results[key] = True
        else:
            results[key] = False

    # Write back to file
    try:
        with open(gemini_settings_path, "w") as f:
            json.dump(settings, f, indent=2)
        return results
    except Exception:
        return dict.fromkeys(extensions.keys(), False)


# ============================================================================
# Main CLI Group
# ============================================================================


@click.group()
@click.version_option(version="0.1.0", prog_name="manage")
def cli() -> None:
    """Unified DevOps CLI for Oracle + Vertex AI Demo.

    This tool manages project initialization, prerequisites, database deployment,
    and configuration across two deployment modes:

    - managed: Oracle 23ai Free container via Docker/Podman (we control it)
    - external: Connect to existing database (auto-detects wallet for mTLS)
    """


# ============================================================================
# INIT COMMAND - Project Initialization
# ============================================================================


@cli.command()
@click.option(
    "--mode",
    type=click.Choice(["managed", "external"], case_sensitive=False),
    help="Deployment mode (auto-detect if not specified)",
)
@click.option(
    "--run-install",
    is_flag=True,
    help="Automatically run 'install all' after initialization",
)
@click.option(
    "--run-doctor",
    is_flag=True,
    help="Automatically run 'doctor' after initialization",
)
@click.option(
    "--non-interactive",
    is_flag=True,
    help="Skip interactive prompts (use defaults/env vars)",
)
def init(mode: str | None, run_install: bool, run_doctor: bool, non_interactive: bool) -> None:
    """Initialize project environment from scratch.

    This command:
    1. Detects or prompts for deployment mode (managed or external)
    2. Creates .env file with interactive prompts for all settings
    3. Configures database connection based on mode
    4. Optionally installs prerequisites
    5. Optionally verifies setup

    Modes:
    - managed: Deploy and manage an Oracle container (Docker/Podman)
    - external: Connect to existing database (standard or wallet-based)
    """
    console.rule("[bold blue]Project Initialization", style="blue", align="left")
    console.print()

    # Step 1: Determine deployment mode
    if mode is None:
        if check_env_file():
            # .env exists, detect mode from it
            mode = detect_deployment_mode()
            console.print(f"[cyan]🔍 Auto-detected mode from .env: [bold]{mode}[/bold][/cyan]")
        else:
            # No .env, ask user for mode
            console.print("[yellow]📄 No .env file found[/yellow]")
            if non_interactive:
                mode = "managed"
                console.print(f"[cyan]Using default mode: [bold]{mode}[/bold][/cyan]")
            else:
                mode = Prompt.ask(
                    "Select deployment mode",
                    choices=["managed", "external"],
                    default="managed",
                )

        if not non_interactive and check_env_file():
            change = Confirm.ask("Change deployment mode?", default=False)
            if change:
                mode = Prompt.ask(
                    "Select mode",
                    choices=["managed", "external"],
                    default=mode,
                )
    else:
        console.print(f"[cyan]📌 Using specified mode: [bold]{mode}[/bold][/cyan]")

    console.print()

    # Step 2: Create or update .env
    console.print("[yellow]📄 Configuring environment...[/yellow]")
    if not create_env_interactive(mode, non_interactive):
        console.print("[red]✗ Failed to configure .env file[/red]")
        raise click.Abort
    console.print()

    # Step 3: Show next steps based on mode
    console.print(f"[bold]Next steps for [cyan]{mode}[/cyan] mode:[/bold]")
    console.print()

    if mode == "managed":
        console.print("  1. Run: [cyan]python manage.py install all[/cyan]")
        console.print("  2. Run: [cyan]python manage.py database oracle start[/cyan]")
        console.print("  3. Run: [cyan]uv run app load-fixtures[/cyan]")
    else:  # external
        console.print(
            "  1. (If using wallet) Run: [cyan]python manage.py database oracle wallet extract Wallet_*.zip[/cyan]"
        )
        console.print("  2. Run: [cyan]python manage.py database oracle connect test[/cyan]")
        console.print("  3. Run: [cyan]uv run app load-fixtures[/cyan]")

    console.print()

    # Step 4: Optional auto-install
    if run_install:
        console.rule("[bold yellow]Running Installation", style="yellow")
        console.print()
        ctx = click.get_current_context()
        ctx.invoke(install_all, mode=mode)

    # Step 5: Optional auto-doctor
    if run_doctor:
        console.rule("[bold yellow]Running Health Check", style="yellow")
        console.print()
        ctx = click.get_current_context()
        ctx.invoke(doctor, mode=mode, json_output=False, verbose=False)

    # Final message
    console.print()
    console.rule("[bold green]Initialization Complete!", style="green")
    console.print()
    console.print("[bold green]✓ Project initialized successfully![/bold green]")
    console.print()
    console.print("[bold]Next:[/bold]")
    if not run_install:
        console.print("  • Run [cyan]python manage.py install all[/cyan] to install prerequisites")
    if not run_doctor:
        console.print("  • Run [cyan]python manage.py doctor[/cyan] to verify setup")
    console.print("  • Review and update [cyan].env[/cyan] if needed")
    console.print("  • See [cyan]README.md[/cyan] for detailed setup instructions")
    console.print()


# ============================================================================
# INSTALL COMMAND GROUP - Prerequisites Installation
# ============================================================================


@cli.group()
def install() -> None:
    """Install external tool prerequisites.

    Manages installation of:
    - UV: Astral's fast Python package manager
    - SQLcl: Oracle's SQL command-line tool
    - (Future: Docker, Podman, etc.)
    """


@install.command(name="all")
@click.option(
    "--mode",
    type=click.Choice(["managed", "external"], case_sensitive=False),
    help="Install prerequisites for specific mode (auto-detect if not specified)",
)
@click.option(
    "--if-missing",
    is_flag=True,
    help="Only install if not already present",
)
@click.option(
    "--yes",
    "-y",
    is_flag=True,
    help="Skip confirmation prompts",
)
def install_all(mode: str | None, if_missing: bool, yes: bool) -> None:
    """Install all prerequisites for deployment mode.

    Mode-specific installations:
    - managed: UV, Docker check
    - external: UV
    """
    if mode is None:
        mode = detect_deployment_mode()

    console.rule(f"[bold blue]Installing Prerequisites for '{mode}' Mode", style="blue")
    console.print()

    # UV is required for all modes
    console.print("[bold]Required for all modes:[/bold]")
    console.print("  • UV package manager")
    console.print()

    if mode == "managed":
        console.print("[bold]Additional for managed mode:[/bold]")
        console.print("  • Docker or Podman (checked, not auto-installed)")
        console.print()

    if not yes:
        if not Confirm.ask("Proceed with installation?", default=True):
            console.print("[yellow]Installation cancelled[/yellow]")
            return

    # Install UV
    ctx = click.get_current_context()
    ctx.invoke(install_uv, if_missing=if_missing)

    # For managed mode, check Docker/Podman
    if mode == "managed":
        console.print()
        console.print("[yellow]🐋 Checking for Docker/Podman...[/yellow]")

        has_docker = shutil.which("docker") is not None
        has_podman = shutil.which("podman") is not None

        if has_docker:
            console.print("[green]✓ Docker found[/green]")
        elif has_podman:
            console.print("[green]✓ Podman found[/green]")
        else:
            console.print("[red]✗ Neither Docker nor Podman found[/red]")
            console.print()
            console.print("[yellow]⚠ Managed mode requires Docker or Podman[/yellow]")
            console.print("[dim]Install from: https://www.docker.com/get-started[/dim]")

    console.print()
    console.print("[green]✓ Installation complete![/green]")


@install.command(name="list")
def install_list() -> None:
    """List available installation components."""
    console.rule("[bold blue]Available Installation Components", style="blue")
    console.print()

    table = Table(show_header=True, header_style="bold cyan")
    table.add_column("Component", style="cyan", width=15)
    table.add_column("Required", width=10)
    table.add_column("Modes", width=30)
    table.add_column("Description")

    table.add_row(
        "uv",
        "[green]Yes[/green]",
        "managed, external",
        "Fast Python package manager",
    )
    table.add_row(
        "java",
        "[yellow]Optional[/yellow]",
        "managed, external",
        "Java 11+ (required for SQLcl)",
    )
    table.add_row(
        "sqlcl",
        "[yellow]Optional[/yellow]",
        "managed, external",
        "Oracle SQL command-line tool",
    )
    table.add_row(
        "docker",
        "[yellow]Optional[/yellow]",
        "managed",
        "Container runtime (not auto-installed)",
    )
    table.add_row(
        "gemini-cli",
        "[yellow]Optional[/yellow]",
        "managed, external",
        "Google Gemini CLI (AI terminal assistant)",
    )
    table.add_row(
        "mcp-toolbox",
        "[yellow]Optional[/yellow]",
        "managed, external",
        "MCP Toolbox for Databases",
    )

    console.print(table)
    console.print()
    console.print("[dim]Tip: Run 'python3 manage.py install <component>' to install[/dim]")
    console.print()


@install.command(name="uv")
@click.option(
    "--version",
    help="Specific version to install (default: latest)",
)
@click.option(
    "--if-missing",
    is_flag=True,
    help="Only install if UV not already present",
)
def install_uv(version: str | None, if_missing: bool) -> None:
    """Install Astral's UV package manager.

    UV is a fast Python package manager and project manager.
    Required for all deployment modes.

    Installation:
    - Downloads from: https://astral.sh/uv/install.sh (Linux/Mac)
    - Installs to: ~/.local/bin or %USERPROFILE%\\.local\\bin
    - Adds to PATH if needed
    """
    console.print("[yellow]📦 Installing UV package manager...[/yellow]")
    console.print()

    # Check if already installed
    uv_path = shutil.which("uv")
    if uv_path and if_missing:
        # Get version
        returncode, stdout, _ = run_command(["uv", "--version"], check=False)
        if returncode == 0:
            console.print(f"[green]✓ UV already installed: {stdout.strip()}[/green]")
            console.print(f"[dim]  Location: {uv_path}[/dim]")
            return

    # Platform-specific installation
    if sys.platform.startswith("win"):
        console.print("[yellow]⚠ Windows installation not yet automated[/yellow]")
        console.print()
        console.print("[bold]Manual installation:[/bold]")
        console.print("  1. Visit: https://astral.sh/uv/")
        console.print("  2. Download and run the Windows installer")
        console.print("  3. Add UV to your PATH")
        return

    # Linux/macOS installation
    console.print("[cyan]Downloading UV installer...[/cyan]")

    install_cmd = "curl -LsSf https://astral.sh/uv/install.sh | sh"

    console.print(f"[dim]Running: {install_cmd}[/dim]")
    console.print()

    try:
        result = subprocess.run(
            install_cmd,
            shell=True,
            check=True,
            text=True,
        )

        console.print()
        console.print("[green]✓ UV installed successfully![/green]")
        console.print()

        # Check if in PATH
        uv_path_after = shutil.which("uv")
        if not uv_path_after:
            console.print("[yellow]⚠ UV is not in your PATH yet[/yellow]")
            console.print()
            console.print("[bold]Add to PATH:[/bold]")

            shell = os.getenv("SHELL", "")
            if "zsh" in shell:
                console.print("  echo 'export PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.zshrc")
                console.print("  source ~/.zshrc")
            elif "bash" in shell:
                console.print("  echo 'export PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bashrc")
                console.print("  source ~/.bashrc")
            else:
                console.print("  Add $HOME/.local/bin to your PATH")
            console.print()
            console.print("[dim]Or restart your terminal[/dim]")
        else:
            console.print(f"[green]✓ UV is in PATH: {uv_path_after}[/green]")

    except subprocess.CalledProcessError as e:
        console.print(f"[red]✗ Installation failed: {e}[/red]")
        raise click.Abort()


@install.command(name="sqlcl")
@click.option(
    "--dir",
    "install_dir",
    type=click.Path(),
    help="Installation directory (default: ~/.local/bin)",
)
@click.option(
    "--force",
    is_flag=True,
    help="Reinstall even if already installed",
)
def install_sqlcl(install_dir: str | None, force: bool) -> None:
    """Install Oracle SQLcl command-line tool.

    Optional tool for advanced Oracle database operations.
    Requires Java 11 or higher to be installed.

    IMPORTANT: SQLcl requires Java 11+. Check with 'java -version'.
    """
    from tools.oracle_deploy import cli as oracle_cli

    console.print("[yellow]📦 Installing Oracle SQLcl...[/yellow]")
    console.print()

    # Check for Java before installing
    java_path = shutil.which("java")
    if not java_path:
        console.print("[red]✗ Java not found![/red]")
        console.print()
        console.print("[bold]SQLcl requires Java 11 or higher.[/bold]")
        console.print()
        console.print("[yellow]Install Java on Ubuntu/Debian:[/yellow]")
        console.print("  [cyan]sudo apt update && sudo apt install -y default-jre[/cyan]")
        console.print()
        console.print("[yellow]Or install a specific version (Ubuntu/Debian):[/yellow]")
        console.print("  [cyan]sudo apt install openjdk-17-jre-headless[/cyan]  # Java 17 (recommended)")
        console.print("  [cyan]sudo apt install openjdk-21-jre-headless[/cyan]  # Java 21 (latest LTS)")
        console.print("  [cyan]sudo apt install openjdk-11-jre-headless[/cyan]  # Java 11 (minimum)")
        console.print()
        console.print("[yellow]RHEL/CentOS/Fedora (yum/dnf):[/yellow]")
        console.print("  [cyan]sudo yum install java-17-openjdk[/cyan]           # RHEL/CentOS 7-8")
        console.print("  [cyan]sudo dnf install java-17-openjdk[/cyan]           # RHEL/CentOS 9+, Fedora")
        console.print("  [cyan]sudo dnf install java-21-openjdk[/cyan]           # Latest LTS")
        console.print()
        console.print("[yellow]Other platforms:[/yellow]")
        console.print("  • macOS: [cyan]brew install openjdk@17[/cyan]")
        console.print("  • Download from: [dim]https://adoptium.net/[/dim]")
        console.print()
        console.print("[dim]After installing Java, run this command again.[/dim]")
        raise click.Abort()

    # Check Java version
    returncode, stdout, _ = run_command(["java", "-version"], check=False)
    if returncode == 0:
        console.print("[green]✓ Java found[/green]")
        # Java version is in stderr, but we can at least confirm it exists
        console.print()

    # Delegate to existing implementation
    args = ["sqlcl", "install"]
    if install_dir:
        args.extend(["--dir", install_dir])
    if force:
        args.append("--force")

    ctx = click.get_current_context()
    try:
        oracle_cli.main(args, standalone_mode=False)
    except SystemExit:
        pass  # Click may raise SystemExit(0)

    # Post-installation instructions
    console.print()
    console.print("[bold]Test SQLcl:[/bold]")
    console.print("  [cyan]sql -V[/cyan]")
    console.print()
    console.print("[dim]Note: Make sure ~/.local/bin is in your PATH[/dim]")

    # Configure Gemini MCP integration if Gemini CLI is installed
    gemini_path = shutil.which("gemini")
    if gemini_path:
        console.print()
        console.print("[yellow]🔐 Configuring SQLcl MCP integration...[/yellow]")

        # Step 1: Configure saved connection with password
        success, message = configure_sqlcl_connection_with_password()
        if success:
            console.print(f"[green]✓ {message}[/green]")
        else:
            console.print(f"[yellow]⚠ Password configuration: {message}[/yellow]")
            console.print(
                "[dim]  Ensure .env has DATABASE_USER, DATABASE_PASSWORD, DATABASE_HOST, DATABASE_SERVICE_NAME[/dim]"
            )

        # Step 2: Configure Gemini MCP server
        if configure_gemini_mcp_sqlcl():
            console.print("[green]✓ Configured SQLcl as Gemini MCP server[/green]")
            if success:
                console.print("[dim]  SQLcl is now fully configured for MCP access[/dim]")
            else:
                console.print("[dim]  Note: Password still needs to be configured[/dim]")
        else:
            console.print("[yellow]⚠ Could not auto-configure Gemini MCP[/yellow]")
            console.print("[dim]  You can manually add SQLcl to ~/.gemini/settings.json[/dim]")


@install.command(name="gemini-cli")
@click.option(
    "--if-missing",
    is_flag=True,
    help="Only install if not already present",
)
def install_gemini_cli(if_missing: bool) -> None:
    """Install Google Gemini CLI.

    AI-powered terminal assistant with access to Gemini 2.5 Pro.
    Requires Node.js 18 or higher.

    Features:
    - Free tier: 60 requests/min, 1000 requests/day
    - 1M token context window
    - Built-in tools: Google Search, file ops, shell commands
    """
    console.print("[yellow]📦 Installing Google Gemini CLI...[/yellow]")
    console.print()

    # Check if already installed
    gemini_path = shutil.which("gemini")
    if gemini_path and if_missing:
        returncode, stdout, _ = run_command(["gemini", "--version"], check=False)
        if returncode == 0:
            console.print(f"[green]✓ Gemini CLI already installed: {stdout.strip()}[/green]")
            return

    # Check for Node.js
    node_path = shutil.which("node")
    if not node_path:
        console.print("[red]✗ Node.js not found![/red]")
        console.print()
        console.print("[bold]Gemini CLI requires Node.js 18 or higher.[/bold]")
        console.print()
        console.print("[yellow]Install Node.js on Ubuntu/Debian:[/yellow]")
        console.print("  [cyan]curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -[/cyan]")
        console.print("  [cyan]sudo apt-get install -y nodejs[/cyan]")
        console.print()
        console.print("[yellow]RHEL/CentOS/Fedora:[/yellow]")
        console.print("  [cyan]curl -fsSL https://rpm.nodesource.com/setup_20.x | sudo bash -[/cyan]")
        console.print("  [cyan]sudo yum install -y nodejs[/cyan]  # or dnf")
        console.print()
        console.print("[yellow]Other platforms:[/yellow]")
        console.print("  • macOS: [cyan]brew install node@20[/cyan]")
        console.print("  • Download from: [dim]https://nodejs.org/[/dim]")
        console.print()
        raise click.Abort()

    # Check Node.js version
    returncode, stdout, _ = run_command(["node", "--version"], check=False)
    if returncode == 0:
        version = stdout.strip()
        console.print(f"[green]✓ Node.js found: {version}[/green]")
        console.print()

    # Install via npm
    console.print("[cyan]Installing via npm...[/cyan]")
    console.print("[dim]Running: npm install -g @google/gemini-cli[/dim]")
    console.print()

    try:
        result = subprocess.run(
            ["npm", "install", "-g", "@google/gemini-cli"],
            check=True,
            text=True,
        )

        console.print()
        console.print("[green]✓ Gemini CLI installed successfully![/green]")
        console.print()

        # Configure popular MCP extensions
        console.rule("[bold cyan]MCP Extensions Configuration", style="cyan", align="left")
        console.print()
        console.print("[bold]Gemini CLI supports MCP (Model Context Protocol) extensions.[/bold]")
        console.print("These extensions enhance Gemini with additional capabilities.")
        console.print()

        # Check if SQLcl is installed and configure if available
        sqlcl_path = shutil.which("sql")
        sqlcl_configured = False
        if sqlcl_path:
            console.print()
            console.print("[bold cyan]SQLcl (Oracle Database)[/bold cyan]")
            console.print("[dim]Oracle database operations and SQL execution[/dim]")
            if Confirm.ask("Configure SQLcl MCP server?", default=True):
                # Step 1: Configure saved connection with password
                success, message = configure_sqlcl_connection_with_password()
                if success:
                    console.print(f"[green]✓[/green] {message}")
                else:
                    console.print(f"[yellow]⚠[/yellow] Password config: {message}")
                    console.print(
                        "[dim]  Ensure .env has DATABASE_USER, DATABASE_PASSWORD, DATABASE_HOST, DATABASE_SERVICE_NAME[/dim]"
                    )

                # Step 2: Configure Gemini MCP server
                if configure_gemini_mcp_sqlcl():
                    console.print("[green]✓[/green] SQLcl MCP server configured")
                    sqlcl_configured = True
                else:
                    console.print("[red]✗[/red] Failed to configure SQLcl MCP server")

        results = configure_gemini_mcp_extensions(interactive=True)

        # Show configuration results
        console.print()
        console.print("[bold]MCP Configuration Summary:[/bold]")
        if sqlcl_configured:
            console.print("  [green]✓[/green] sqlcl (Oracle Database)")
        for key, success in results.items():
            if success:
                console.print(f"  [green]✓[/green] {key}")
            else:
                console.print(f"  [dim]⊘ {key} (skipped)[/dim]")

        console.print()
        console.print("[bold]First run:[/bold]")
        console.print("  [cyan]gemini[/cyan]  # Launch interactive CLI")
        console.print()
        console.print("[bold]Authentication:[/bold]")
        console.print("  • Login with Google (free tier)")
        console.print("  • Or use API key from Google AI Studio")
        console.print()
        console.print("[dim]Learn more: https://github.com/google-gemini/gemini-cli[/dim]")

    except subprocess.CalledProcessError as e:
        console.print(f"[red]✗ Installation failed: {e}[/red]")
        raise click.Abort()


@install.command(name="mcp-toolbox")
@click.option(
    "--if-missing",
    is_flag=True,
    help="Only install if not already present",
)
@click.option(
    "--version",
    default="v0.16.0",
    help="Specific version to install (default: v0.16.0)",
)
def install_mcp_toolbox(if_missing: bool, version: str) -> None:
    """Install MCP Toolbox for Databases.

    Open-source MCP server for databases (AlloyDB, Spanner, Cloud SQL, etc.)
    Requires Go 1.21 or higher for installation from source.

    Binary downloads available for Linux, macOS (Intel/ARM), and Windows.
    """
    console.print("[yellow]📦 Installing MCP Toolbox for Databases...[/yellow]")
    console.print()

    # Check if already installed
    toolbox_path = shutil.which("toolbox")
    if toolbox_path and if_missing:
        console.print(f"[green]✓ MCP Toolbox already installed at {toolbox_path}[/green]")
        return

    # Detect platform
    import platform

    system = platform.system().lower()
    machine = platform.machine().lower()

    # Map to download OS/arch
    if (system == "linux" and "x86_64" in machine) or "amd64" in machine:
        os_arch = "linux/amd64"
    elif system == "darwin" and ("arm64" in machine or "aarch64" in machine):
        os_arch = "darwin/arm64"
    elif system == "darwin":
        os_arch = "darwin/amd64"
    elif system == "windows":
        os_arch = "windows/amd64"
    else:
        console.print(f"[red]✗ Unsupported platform: {system}/{machine}[/red]")
        raise click.Abort()

    console.print(f"[cyan]Detected platform: {os_arch}[/cyan]")
    console.print()

    # Download binary
    download_url = f"https://storage.googleapis.com/genai-toolbox/{version}/{os_arch}/toolbox"
    install_path = Path.home() / ".local" / "bin" / "toolbox"

    console.print(f"[cyan]Downloading from: {download_url}[/cyan]")
    console.print()

    try:
        import httpx

        with httpx.stream("GET", download_url, follow_redirects=True, timeout=60) as response:
            response.raise_for_status()

            # Create install directory
            install_path.parent.mkdir(parents=True, exist_ok=True)

            # Download file
            with open(install_path, "wb") as f:
                f.writelines(response.iter_bytes(chunk_size=8192))

        # Make executable
        install_path.chmod(0o755)

        console.print(f"[green]✓ MCP Toolbox installed to {install_path}[/green]")
        console.print()
        console.print("[bold]Verify installation:[/bold]")
        console.print("  [cyan]toolbox --version[/cyan]")
        console.print()
        console.print("[bold]Supported databases:[/bold]")
        console.print("  • AlloyDB for PostgreSQL (including AlloyDB Omni)")
        console.print("  • Cloud SQL (PostgreSQL, MySQL, SQL Server)")
        console.print("  • Spanner, Bigtable")
        console.print("  • Self-managed MySQL and PostgreSQL")
        console.print()
        console.print("[dim]Learn more: https://googleapis.github.io/genai-toolbox/[/dim]")

    except Exception as e:
        console.print(f"[red]✗ Installation failed: {e}[/red]")
        console.print()
        console.print("[yellow]Alternative: Install via Go[/yellow]")
        console.print(f"  [cyan]go install github.com/googleapis/genai-toolbox@{version}[/cyan]")
        raise click.Abort()


# ============================================================================
# DOCTOR COMMAND - Prerequisites Verification
# ============================================================================


@cli.command()
@click.option(
    "--mode",
    type=click.Choice(["managed", "external"], case_sensitive=False),
    help="Check prerequisites for specific mode (auto-detect if not specified)",
)
@click.option(
    "--json",
    "json_output",
    is_flag=True,
    help="Output results as JSON",
)
@click.option(
    "--verbose",
    "-v",
    is_flag=True,
    help="Show detailed diagnostic information",
)
def doctor(mode: str | None, json_output: bool, verbose: bool) -> None:
    """Verify all prerequisites and configuration.

    Checks:
    - .env file exists and is valid
    - UV package manager installed
    - Mode-specific requirements (Docker for managed, wallet if configured)
    - Database connectivity (optional)

    Exit codes:
    - 0: All checks passed
    - 1: One or more checks failed
    """
    import json

    if mode is None:
        mode = detect_deployment_mode()

    if not json_output:
        console.rule(f"[bold blue]Health Check for '{mode}' Mode", style="blue")
        console.print()

    checks = {
        "env_file": False,
        "uv_installed": False,
        "mode_specific": {},
        "overall": False,
    }

    # Check .env file
    if not json_output:
        console.print("[yellow]📄 Checking .env file...[/yellow]")

    checks["env_file"] = check_env_file()
    if not json_output:
        if checks["env_file"]:
            console.print("[green]✓ .env file exists[/green]")
        else:
            console.print("[red]✗ .env file not found[/red]")
            console.print("[dim]  Run: python manage.py init[/dim]")

    # Check UV
    if not json_output:
        console.print("[yellow]📦 Checking UV package manager...[/yellow]")

    uv_path = shutil.which("uv")
    checks["uv_installed"] = uv_path is not None

    if not json_output:
        if checks["uv_installed"]:
            returncode, stdout, _ = run_command(["uv", "--version"], check=False)
            version = stdout.strip() if returncode == 0 else "unknown"
            console.print(f"[green]✓ UV installed: {version}[/green]")
            if verbose:
                console.print(f"[dim]  Location: {uv_path}[/dim]")
        else:
            console.print("[red]✗ UV not found[/red]")
            console.print("[dim]  Run: python manage.py install uv[/dim]")

    # Mode-specific checks
    if not json_output:
        console.print(f"[yellow]🔧 Checking '{mode}' mode prerequisites...[/yellow]")

    if mode == "managed":
        # Check Docker/Podman
        has_docker = shutil.which("docker") is not None
        has_podman = shutil.which("podman") is not None
        checks["mode_specific"]["container_runtime"] = has_docker or has_podman

        if not json_output:
            if has_docker:
                console.print("[green]✓ Docker found[/green]")
            elif has_podman:
                console.print("[green]✓ Podman found[/green]")
            else:
                console.print("[red]✗ Neither Docker nor Podman found[/red]")
                console.print("[dim]  Install from: https://www.docker.com/get-started[/dim]")

    elif mode == "external":
        # Check wallet location (if configured - wallet is optional for external)
        wallet_location = os.getenv("WALLET_LOCATION") or os.getenv("TNS_ADMIN")
        if wallet_location:
            checks["mode_specific"]["wallet_configured"] = True
            wallet_path = Path(wallet_location)
            checks["mode_specific"]["wallet_exists"] = wallet_path.exists()

            if wallet_path.exists():
                cwallet = wallet_path / "cwallet.sso"
                tnsnames = wallet_path / "tnsnames.ora"
                checks["mode_specific"]["wallet_valid"] = cwallet.exists() and tnsnames.exists()
            else:
                checks["mode_specific"]["wallet_valid"] = False

            if not json_output:
                console.print(f"[green]✓ Wallet location configured: {wallet_location}[/green]")
                if checks["mode_specific"].get("wallet_exists"):
                    console.print("[green]✓ Wallet directory exists[/green]")
                    if checks["mode_specific"].get("wallet_valid"):
                        console.print("[green]✓ Wallet files valid[/green]")
                    else:
                        console.print("[red]✗ Wallet missing required files[/red]")
                else:
                    console.print("[red]✗ Wallet directory not found[/red]")
        # Wallet not configured - this is OK for external mode
        elif not json_output:
            console.print("[dim]ℹ No wallet configured (using standard connection)[/dim]")

    # Overall status
    checks["overall"] = checks["env_file"] and checks["uv_installed"] and all(checks["mode_specific"].values())

    # Output results
    if json_output:
        print(json.dumps(checks, indent=2))
    else:
        console.print()
        if checks["overall"]:
            console.print("[bold green]✓ All checks passed![/bold green]")
            console.print()
            console.print("[bold]Next steps:[/bold]")
            console.print("  • Run [cyan]python manage.py connect test[/cyan] to verify database connection")
            console.print("  • Run [cyan]uv run app run[/cyan] to start the application")
        else:
            console.print("[bold red]✗ Some checks failed[/bold red]")
            console.print()
            console.print("[bold]To fix:[/bold]")
            if not checks["env_file"]:
                console.print("  • Run [cyan]python manage.py init[/cyan]")
            if not checks["uv_installed"]:
                console.print("  • Run [cyan]python manage.py install uv[/cyan]")
            if not all(checks["mode_specific"].values()):
                console.print("  • Check mode-specific requirements above")

    if not checks["overall"]:
        raise click.Abort()


# ============================================================================
# PROXY COMMANDS - Delegate to tools/oracle_deploy.py
# ============================================================================


@cli.group(name="database")
def database_group() -> None:
    """Manage database operations.

    Commands for database management across different providers.
    """


@database_group.group(name="oracle")
def oracle_group() -> None:
    """Manage Oracle database operations.

    Commands for deploying and managing Oracle databases, wallets, and connections.
    Requires Docker or Podman for managed mode.
    """


@oracle_group.command(name="start-local-container")
@click.option("--pull", is_flag=True, help="Pull latest image before starting")
@click.option("--recreate", is_flag=True, help="Remove and recreate container if exists")
def oracle_start(pull: bool, recreate: bool) -> None:
    """Start Oracle database container."""
    from tools.oracle_deploy import cli as oracle_cli

    args = ["database", "start"]
    if pull:
        args.append("--pull")
    if recreate:
        args.append("--recreate")

    try:
        oracle_cli.main(args, standalone_mode=False)
    except SystemExit:
        pass


@oracle_group.command(name="stop-local-container")
@click.option("--timeout", default=30, help="Seconds to wait before forcing stop")
def oracle_stop(timeout: int) -> None:
    """Stop Oracle database container."""
    from tools.oracle_deploy import cli as oracle_cli

    try:
        oracle_cli.main(["database", "stop", "--timeout", str(timeout)], standalone_mode=False)
    except SystemExit:
        pass


@oracle_group.command(name="status")
@click.option("--verbose", "-v", is_flag=True, help="Show detailed status")
def oracle_status(verbose: bool) -> None:
    """Check database container status."""
    from tools.oracle_deploy import cli as oracle_cli

    args = ["database", "status"]
    if verbose:
        args.append("--verbose")

    try:
        oracle_cli.main(args, standalone_mode=False)
    except SystemExit:
        pass


@oracle_group.command(name="local-container-logs")
@click.option("--follow", "-f", is_flag=True, help="Follow log output")
@click.option("--tail", default=50, help="Number of lines to show from end of logs")
def oracle_logs(follow: bool, tail: int) -> None:
    """View database container logs."""
    from tools.oracle_deploy import cli as oracle_cli

    args = ["database", "logs", "--tail", str(tail)]
    if follow:
        args.append("--follow")

    try:
        oracle_cli.main(args, standalone_mode=False)
    except SystemExit:
        pass


@oracle_group.command(name="wipe-local-container")
@click.option("--volumes", is_flag=True, help="Remove volumes as well")
@click.option("--force", is_flag=True, help="Force removal without confirmation")
def oracle_remove(volumes: bool, force: bool) -> None:
    """Remove Oracle database container."""
    from tools.oracle_deploy import cli as oracle_cli

    args = ["database", "remove"]
    if volumes:
        args.append("--volumes")
    if force:
        args.append("--force")

    try:
        oracle_cli.main(args, standalone_mode=False)
    except SystemExit:
        pass


@oracle_group.group(name="wallet")
def wallet_group() -> None:
    """Manage Autonomous Database wallets.

    Extract, configure, and validate Oracle Autonomous Database wallet files.
    """


@wallet_group.command(name="extract")
@click.argument("wallet_zip", type=click.Path(exists=True))
@click.option("--dest", type=click.Path(), help="Destination directory (default: .envs/tns)")
def wallet_extract(wallet_zip: str, dest: str | None) -> None:
    """Extract wallet zip file."""
    from tools.oracle_deploy import cli as oracle_cli

    args = ["wallet", "extract", wallet_zip]
    if dest:
        args.extend(["--dest", dest])

    try:
        oracle_cli.main(args, standalone_mode=False)
    except SystemExit:
        pass


@wallet_group.command(name="configure")
@click.option("--wallet-dir", type=click.Path(exists=True), help="Wallet directory")
@click.option("--non-interactive", is_flag=True, help="Skip interactive prompts")
def wallet_configure(wallet_dir: str | None, non_interactive: bool) -> None:
    """Interactive wallet configuration wizard."""
    from tools.oracle_deploy import cli as oracle_cli

    args = ["wallet", "configure"]
    if wallet_dir:
        args.extend(["--wallet-dir", wallet_dir])
    if non_interactive:
        args.append("--non-interactive")

    try:
        oracle_cli.main(args, standalone_mode=False)
    except SystemExit:
        pass


@oracle_group.group(name="connect")
def connect_group() -> None:
    """Test database connections.

    Test connectivity to Oracle databases in any deployment mode.
    """


@connect_group.command(name="test")
@click.option(
    "--mode",
    type=click.Choice(["managed", "external"]),
    help="Deployment mode (auto-detect if not specified)",
)
@click.option("--timeout", default=10, help="Connection timeout in seconds")
def connect_test(mode: str | None, timeout: int) -> None:
    """Test database connection."""
    from tools.oracle_deploy import cli as oracle_cli

    args = ["connect", "test", "--timeout", str(timeout)]
    if mode:
        args.extend(["--mode", mode])

    try:
        oracle_cli.main(args, standalone_mode=False)
    except SystemExit:
        pass


@cli.command(name="status")
@click.option("--verbose", "-v", is_flag=True, help="Show detailed diagnostics")
@click.option(
    "--mode",
    type=click.Choice(["managed", "external"]),
    help="Check specific deployment mode",
)
def status(verbose: bool, mode: str | None) -> None:
    """Check overall system health.

    Comprehensive health check of all deployment components:
    - Container runtime (Docker/Podman)
    - Database container (if managed)
    - SQLcl installation
    - Wallet configuration (if configured)
    - Database connectivity
    """
    from tools.oracle_deploy import cli as oracle_cli

    args = ["status"]
    if verbose:
        args.append("--verbose")
    if mode:
        args.extend(["--mode", mode])

    try:
        oracle_cli.main(args, standalone_mode=False)
    except SystemExit:
        pass


# ============================================================================
# Main Entry Point
# ============================================================================


def main() -> None:
    """Main entry point."""
    try:
        cli()
    except KeyboardInterrupt:
        console.print("\n[yellow]Interrupted by user[/yellow]")
        sys.exit(130)
    except Exception as e:
        console.print(f"[red]Error: {e}[/red]")
        sys.exit(1)


if __name__ == "__main__":
    main()
